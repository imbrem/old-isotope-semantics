%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}
\newcommand{\sorry}{\textcolor{red}{\textbf{sorry}}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{TODO \arabic{todos}:} #1}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

% Math
\newcommand{\nats}{\mathbb{N}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{\Rightarrow}
\newcommand{\ctt}{\ms{tt}}
\newcommand{\cff}{\ms{ff}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2\;\ms{in}\;#3}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\lbrb}[2]{\brb{\lbl{#1}}{#2}}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\ewhere}[2]{\ms{then}\;#1\;\ms{where}\;#2}
\newcommand{\where}[2]{#1\;\ms{where}\;#2}
\newcommand{\wbranch}[3]{#1(#2) \lto #3}
\newcommand{\lwbranch}[3]{\wbranch{\lbl{#1}}{#2}{#3}}
\newcommand{\bsplice}[3]{#1(#2)\;\{#3\}}
%\newcommand{\lbsplice}[3]{\bsplice{\lbl{#1}}{#2}{#3}}
\newcommand{\csplits}[3]{#1 \mapsto #2;#3}
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[2]{#1 \rightsquigarrow #2}
\newcommand{\tlin}[2]{#2 \subseteq \ms{lin}(#1)}
\newcommand{\ltlin}[3]{#3 \subseteq \ms{lin}(#1) \cap #2}
\newcommand{\thyp}[3]{#1: {#2}^{#3}}
\newcommand{\lhyp}[3]{#1[#2](#3)}
\newcommand{\llhyp}[3]{\lhyp{\lbl{#1}}{#2}{#3}}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\taff}{{\{\ms{a}\}}}
\newcommand{\trel}{{\{\ms{r}\}}}
\newcommand{\tint}{{\{\ms{a}, \ms{r}\}}}
\newcommand{\hasty}[5]{#1 \vdash_{#2} #3: {#4}^{#5}}
\newcommand{\haslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\lhaslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\issubst}[3]{#1: #2 \mapsto #3}
\newcommand{\lbsubst}[3]{#1: #2 \rightsquigarrow #3}
\newcommand{\exprletsubst}[2]{{#1};{#2}}
\newcommand{\stmtletsubst}[2]{{#1};{#2}}
\newcommand{\mhole}[1]{{#1}^?}
\newcommand{\lhole}[1]{?#1}
\newcommand{\mhasty}[6]{#1;#2 \vdash_{#3} #4: {#5}^{#6}}
\newcommand{\mhaslb}[4]{#1;#2 \vdash #3 \rhd #4}
\newcommand{\mlhaslb}[4]{#1;#2 \vdash #3 \rhd #4}
\newcommand{\tyhole}[5]{#1: #2 \mapsto_{#3} {#4}^{#5}}
\newcommand{\blkhole}[3]{#1: #2 \mapsto #3}
\newcommand{\cfghole}[3]{#1: #2 \mapsto #3}
\newcommand{\substctx}[2]{{#1}^{#2}}
\newcommand{\substlbs}[2]{{#1}^{#2}}
\newcommand{\restrictsubst}[2]{{#1}_{#2}}
\newcommand{\subsubst}[2]{#1 \subseteq #2}
\newcommand{\isrw}[3]{#1: #2 \mapsto #3}
\newcommand{\mbind}{\mathbin{{>}\hspace{-0.1em}{>}\hspace{-0.1em}{=}}}
% \newcommand{\strictlbsubst}[3]{#1: #2 \rightsquigarrow_= #3}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}
\newcommand{\upg}[2]{{#1}^{\uparrow #2}}

% Branding
\newcommand{\isotopessa}{\ms{isotope_{SSA}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Effectful Semantics for Substructural SSA}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\begin{abstract}
  Static single-assignment form (SSA) is one of the most widely used
  compiler intermediate representations. In this paper, we build on
  the observation that SSA can be seen as a language of basic blocks
  with arguments (or first-order procedures tail-calling one another)
  to give a type theory for SSA programs. Notably, the type system and
  equational theory of our language is designed to support
  substituting impure terms for variables, which makes it easy to
  validate compiler optimisations such as hoisting assignments out of
  loops.

  We give a categorical axiomatisation of our type theory and show
  that our equational theory is sound with respect to it. Our
  categorical semantics generalises the notions of premonoidal
  category and Freyd category to support substructural features,
  including both support for substructural types, as well as
  F\"{u}hrmann's notion of central, copyable and discardable
  morphisms.

  Finally, we exhibit a number of concrete models of our categorical
  axiomatisation, including in particular a model of TSO-style weak
  memory based on the semantics of \citet{sparky}. This demonstrates
  that our approach is strong enough to connect machine models of
  concurrency to compiler IRs supporting a rich collection of sound
  rewrites.
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011742</concept_id>
  <concept_desc>Theory of computation~Separation logic</concept_desc>
  <concept_significance>300</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[300]{Theory of computation~Separation logic}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle


\section{Introduction}

Static Single Assignment, or SSA, has been a cornerstone of compiler
design ever since its introduction by \cite{ssa-original} in the late
1980s. Older compiler intermediate representations permitted the same
local variable to be assigned multiple times, whereas SSA requires
each variable bindings to be immutable -- they cannot be modified
after initialisation. This makes many dataflow analyses easier to
compute, and (just as in functional languages) makes it much easier to
justify compiler optimisations in terms of equational rewrites.

In fact, the relationship between SSA form and functional programming
has been known for decades: \citet{kelsey-ssa-cps} showed that SSA can
be seen as a subset of continuation-passing style, and
\citet{appel-ssa} built on this to observe that every SSA program can
be viewed as a collection of first-order functions which tail-call one
another. This makes the equivalence of the functional view to the
traditional $\phi$-node presentation very easy to see. In the
functional style, each tail call lists its arguments. In contrast, a
$\phi$-node collects together the arguments from every callsite, which
lets the tail-calls/jumps to omit their arguments. Thus, the main
difference between SSA and a functional program is where in the
program text the arguments to a tail call are listed.

\TODO{Example here?}

This ``basic blocks with arguments'' presentation of SSA has become
very popular in industry, with compiler backends such as
Cranelift~\cite{cranelift}, MLIR~\cite{mlir}, and SIL~\cite{SIL} all
using this representation. This tight connection might suggest that
the semantics of SSA representations is trivial: we can just interpret
an SSA program as a corresponding functional program, and then rewrite
the SSA programs using the equational theory of functional programs.

While this is a perfectly sound thing to do, it is not strong enough
to write a good compiler. Compiler IRs like SSA are fundamentally
about effectful programs, and the equational theory of effectful
functional programs is very weak. Instead of a full substitution rule,
the equational theory of impure functional languages only justifies
substituting values for variables (the $\beta$-value rule). This weak
substitution rule suffices to validate some basic compiler
optimisations such as constant propagation and copy propagation, but
is not strong enough to justify many other essential compiler
optimisations. For example, hoisting a store out of a loop or
conditional involves moving an effectful term (an assignment) out of
its original position in the program. As another example, dead store
elimination removes an effectful term from the program altogether. \todo{Another example?}

These examples illustrate that many optimisations require taking
\emph{effectful} terms and moving them around and substituting them
for variables.







% 
% , on which projects such as the LLVM compiler infrastructure, GCC's GIMPLE intermediate representation, Cranelift, and MLIR are based. One of the core advantages of putting programs in SSA form is the ability to reason about programs in a more equational manner: since variables always have exactly one definition, we can justify complex optimizations like global value numbering (which would otherwise need to take into account complex flow-sensitive definitions) and more easily implement various analyses. 
% 
\TODO{text...}

\TODO{cite \cite{rosen-gvn-1988} somewhere?}

\paragraph{Contributions}

\begin{itemize}
\item We have a syntax and type system for SSA-style programs. We include support for substructural types, and our type-theoretic syntax makes formulating inlining and rewriting easier than in the traditional CFG-based formulations. 
\item We show that our language has a compositional intepretation in any effectful category with an Elgot structure. We use this structure to give generic proofs of the expected substitution properties as well as prove the soundness of an equational theory for the language.
\item Our generic equational theory justifies a variety of powerful optimisation techniques, including E-graph rewriting, inlining, loop fusion, hoisting, and strength reduction. 
\item We show how Elgot monads give rise to models of our language. We use this to derive semantics from a general trace monad, and show that various monad transformers such as state transformers preserve the needed Elgot structure. 
\item We use these tools to demonstrate the existence of a variety of concrete models satisfying these categorical axioms. Starting first from simple languges such as state plus printing, we also show how more challenging semantics such as the TSO semantics for weak memory also fit into our framework. This thus gives rise to an SSA-based IR with support for weak memory operations, which is fully semantically-justified.
\item \todo{We also have a small implementation, which \ldots}
\item Our weak memory semantics and our results about Elgot monads are formalised in the Lean theorem prover. \TODO{Other stuff}
\end{itemize}

\section{Background}

In a standard SSA-based compiler, to represent a function, we begin by decomposing it into basic blocks of the following form:
\begin{lstlisting}
'label:
  var = instruction
  ...
  var = instruction
  terminator
\end{lstlisting}
A program written in this manner being in ``SSA form'' simply means that every variable name is defined exactly once. For example,
\begin{lstlisting}
'entry:
  x = 7
  x = add x 2
  ret x
\end{lstlisting}
is not in SSA form, but can easily be converted into SSA form by rewriting it as
\begin{lstlisting}
'entry:
  x0 = 7
  x1 = add x0 2
  ret x1
\end{lstlisting}
Unfortunately, things get a little more tricky when we try to define variables in loops or branches. For example, consider the following code:
\begin{lstlisting}
'entry:
  br arg0 'left `right
'left:
  x = 7
  jmp 'exit
'right:
  x = 3
  jmp 'exit
'exit:
  ret x
\end{lstlisting}
There are two competing definitions of \(x\) in the left and right blocks, and it’s unclear how to disambiguate between them. The usual solution is to introduce a \(\phi\)-node. In particular, we can write:
\begin{lstlisting}
'entry:
  br arg0 'left `right
'left:
  x0 = 7
  jmp 'exit
'right:
  x1 = 3
  jmp 'exit
'exit:
  x2 = phi 'left x0 'right x1
  ret x2
\end{lstlisting}
\TODO{make above into graphs?}
\TODO{segue}
The semantics of SSA, however, can be quite complex to reason about, especially when considering the somewhat unintuitive scoping rules of variables and \(\phi\)-function arguments.

\TODO{basic-blocks with arguments}

\TODO{dominance frontiers}

\TODO{inductive presentation}

\TODO{what we're doing}

\section{SSA Syntax}

\TODO{text}

\begin{figure}
  \begin{center}
    \begin{grammar}
      <\(A, B, C\)> ::= 
      \(X\)
      \;|\; \(\mathbf{1}\)
      \;|\; \(\mathbf{2}\)
      \;|\; \(A \otimes B\)

      <\(a, b, c, e\)> ::= \(x\) 
      \;|\; \(f\;a\)
      \;|\; \((a, b)\) 
      \;|\; \(()\) 
      \;|\; \(\ctt\) 
      \;|\; \(\cff\)
      \;|\; \(\letexpr{x}{a}{e}\)
      \;|\; \(\letexpr{(x, y)}{a}{e}\)
      % \;|\; \(\lbsplice{\ell}{x: A}{t}\)
      
      <\(s, t\)> ::= \(\lbrb{\ell}{a}\) 
      \;|\; \(\ite{e}{s}{t}\)
      \;|\; \(\letstmt{x}{a}{t}\)
      \;|\; \(\letstmt{(x, y)}{a}{t}\)
      \;|\; \(\ewhere{t}{L}\)

      <\(L\)> ::= \(\cdot\) \;|\; \(\lwbranch{\ell}{x: A}{t}, L\)

      <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, \thyp{x}{A}{q}\)

      <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \lbl{\ell}[\Gamma](x: A)\)

      <\(p\)> ::= 0 \;|\; 1

      <\(q\)> ::= \(\varnothing\) 
      \;|\; \(\{\taff\}\) 
      \;|\; \(\{\trel\}\) 
      \;|\; \(\{\taff, \trel\}\)
    \end{grammar}
  \end{center}
  \caption{Grammar for \isotopessa, parametrized over a set of instructions \(f \in \mc{I}\)}
  \Description{Grammar for isotope-SSA}
  \label{fig:ssa-grammar}
\end{figure}

\TODO{late \ms{where}-binding, and other sugar (?)}

\TODO{top-level functions}

\TODO{table of typing judgements}

\TODO{contexts, label-contexts}

\begin{figure}
  \begin{center}        
    \begingroup
    \renewcommand{\arraystretch}{1.5}
    \setlength{\tabcolsep}{2em}
    \begin{tabular}{rl}
        \multicolumn{1}{c}{Judgment} & \multicolumn{1}{c}{Meaning} \\ \hline
        \(\hasty{\Gamma}{p}{x}{A}{q}\) &
        \(a\) is a term of type \(A\) in context \(\Gamma\) with purity \(p\) and quantity \(q\) \\
        \(\haslb{\Gamma}{t}{\ms{L}}\) &
        \(t\) is a block targeting label-set \(\ms{L}\) in context \(\Gamma\) \\
        \(\lhaslb{\ms{L}}{L}{\ms{K}}\) &
        The labels \(L\) send label-set \(\ms{L}\) to label-set \(\ms{K}\) \\
        \(\csplits{\Gamma}{\Delta}{\Xi}\) &
        The context \(\Gamma\) splits into \(\Delta\) and \(\Xi\) \\
        \(\lwk{\ms{L}}{\ms{K}}\) &
        The label-set \(\ms{L}\) weakens to the label-set \(\ms{K}\) \\
        % \(\tlin{A}{q}\) &
        % The type \(A\) can be used with linearity \(q\) \\
        % \(\ltlin{A}{r}{q}\) &
        % The type \(A\) can be used with linearity \(q \subseteq r\)
        % (i.e. \(\tlin{A}{q} \land q \subseteq r\)) \\
        % \(\tlin{\Gamma}{q}\) &
        % The context \(\Gamma\) has linearity \(q\) \\
        \(\cwk{\Gamma}{\Delta}\) &
        \(\Gamma\) is a weakening of \(\Delta\) 
        (i.e. \(\csplits{\Gamma}{\Delta}{\cdot}\))
    \end{tabular}
    \endgroup
  \end{center}
  \caption{Typing judgements for \isotopessa}
  \Description{Typing judgements for isotope-SSA}
  \label{fig:ssa-judgements}
\end{figure}

\TODO{some text about each typing judgement}

\begin{figure}
  \begin{gather*}    
    % \prftree[r]{\rle{base-lin}}{q \subseteq \ms{lin}(X)}{\tlin{X}{q}} \qquad
    \prftree[r]{\rle{unit-lin}}{}{\tlin{\mathbf{1}}{q}} 
    \qquad
    \prftree[r]{\rle{bool-lin}}{}{\tlin{\mathbf{2}}{q}} 
    \qquad
    \prftree[r]{\rle{pair-lin}}{\tlin{A}{q}}{\tlin{B}{q}}{\tlin{A \otimes B}{q}} \\
    \prftree[r]{\rle{nil-lin}}{\tlin{\cdot}{q}} \qquad
    \prftree[r]{\rle{cons-lin}}{\ltlin{A}{r}{q}}{\tlin{\Gamma}{q}}
      {\tlin{\Gamma, \thyp{x}{A}{r}}{q}} \\
    \prftree[r]{\rle{split-nil}}{\csplits{\cdot}{\cdot}{\cdot}} \qquad
    \prftree[r]{\rle{split-left}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {r \subseteq q}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta, \thyp{x}{A}{r}}{\Xi}} \qquad
    \prftree[r]{\rle{split-right}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {r \subseteq q}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta}{\Xi, \thyp{x}{A}{r}}} \\
    \prftree[r]{\rle{split-dup}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\ltlin{A}{q}{\trel}}
      {r, s \subseteq q}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta, \thyp{x}{A}{r}}{\Xi, \thyp{x}{A}{s}}}
      \qquad
    \prftree[r]{\rle{split-drop}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\ltlin{A}{q}{\taff}}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta}{\Xi}}
      \\
    \prftree[r]{\rle{join-nil}}{\lwk{\cdot}{\cdot}} \qquad
    \prftree[r]{\rle{join-cons}}
      {\lwk{\ms{L}}{\ms{K}}}
      {\cwk{\Gamma}{\Delta}}
      {\lwk{\ms{L}, \llhyp{\ell}{\Gamma}{A}}{\ms{K}, \llhyp{\ell}{\Delta}{A}}} 
      \qquad
    \prftree[r]{\rle{join-zero}}
      {\lwk{\ms{L}}{\ms{K}}}
      {\lwk{\ms{L}}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}} 
  \end{gather*}
  \caption{Structural rules for \isotopessa}
  \Description{Structural rules for isotope-SSA}
  \label{fig:ssa-structural}
\end{figure}

\TODO{some text about each structural rule}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma}{\thyp{x}{A}{q}}}
      {\hasty{\Gamma}{p}{x}{A}{q}} \qquad
    \prftree[r]{\rle{app}}
      {f \in \mc{I}_p^q(A, B)}
      {\hasty{\Gamma}{1}{a}{A}{q}}
      {\hasty{\Gamma}{p}{f\;a}{B}{q}} \qquad
    \prftree[r]{\rle{pair}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta}{1}{a}{A}{q}}
      {\hasty{\Xi}{1}{b}{B}{q}}
      {\hasty{\Gamma}{p}{(a, b)}{A \otimes B}{q}} \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma}{\cdot}}
      {\hasty{\Gamma}{p}{()}{\mb{1}}{q}} \qquad
    \prftree[r]{\rle{true}}
      {\cwk{\Gamma}{\cdot}}
      {\hasty{\Gamma}{p}{\ctt}{\mb{2}}{q}} \qquad
    \prftree[r]{\rle{false}}
      {\cwk{\Gamma}{\cdot}}
      {\hasty{\Gamma}{p}{\cff}{\mb{2}}{q}} \\
    \prftree[r]{\rle{let}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta, \thyp{x}{A}{}}{p}{e}{B}{q}}
      {\hasty{\Xi}{1}{a}{A}{q}}
      {\hasty{\Gamma}{p}{\letexpr{x}{a}{e}}{B}{q}} \qquad
    % \prftree[r]{\rle{blk}}
    %   {\haslb{\Gamma}{t}{\llhyp{\ell}{\cdot}{A}}}
    %   {\hasty{\Gamma}{0}{\lbsplice{\ell}{A}{t}}{A}{\varnothing}} 
      \\
    \prftree[r]{\rle{let2}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{p}{e}{C}{q}}
      {\hasty{\Xi}{1}{a}{A \otimes B}{q}}
      {\hasty{\Gamma}{p}{\letexpr{(x, y)}{a}{e}}{C}{q}}
  \end{gather*}
  \caption{Typing rules for \isotopessa terms}
  \Description{Typing rules for isotope-SSA terms}
  \label{fig:ssa-term-typing}
\end{figure}

\TODO{some text about each typing rule}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{br}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\lwk{\llhyp{\ell}{\Delta}{A}}{\ms{L}}}
      {\hasty{\Xi}{1}{a}{A}{\tint}}
      {\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} 
    \\
    \prftree[r]{\rle{ite}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta}{1}{e}{\mb{2}}{\tint}}
      {\haslb{\Xi}{s}{\ms{L}}}
      {\haslb{\Xi}{t}{\ms{L}}}
      {\haslb{\Gamma}{\ite{e}{s}{t}}{\ms{L}}} 
    \\
    \prftree[r]{\rle{let-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\haslb{\Delta, \thyp{x}{A}{}}{t}{\ms{L}}}
      {\hasty{\Xi}{0}{a}{A}{q}}
      {\haslb{\Gamma}{\letstmt{x}{a}{t}}{\ms{L}}} 
    \\
    \prftree[r]{\rle{let2-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\haslb{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{t}{\ms{L}}}
      {\hasty{\Xi}{0}{a}{A \otimes B}{q}}
      {\haslb{\Gamma}{\letstmt{(x, y)}{a}{t}}{\ms{L}}} \qquad
    \prftree[r]{\rle{where}}
      {\haslb{\Gamma}{t}{\ms{L}}}
      {\lhaslb{\ms{L}}{L}{\ms{K}}}
      {\haslb{\Gamma}{\ewhere{t}{L}}{\ms{K}}}
    \\
    \prftree[r]{\rle{nil-br}}
      {\lhaslb{\ms{L}}{\cdot}{\ms{L}}} \qquad
    \prftree[r]{\rle{cons-br}}
      {\lhaslb{\ms{L}}{L}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      {\haslb{\Gamma, \thyp{x}{A}{}}{t}{\ms{L}}}
      {\lhaslb{\ms{L}}{L, \lwbranch{\ell}{x: A}{t}}{\ms{K}}}
  \end{gather*}
  \caption{Typing rules for \isotopessa blocks}
  \Description{Typing rules for isotope-SSA blocks}
  \label{fig:ssa-block-typing}
\end{figure}

\TODO{some text about each block typing rule}

\subsection{Syntactic Metatheory}

\begin{theorem}[Weakening] \
  \begin{itemize}
    \item If \(\cwk{\Gamma}{\Delta}\) and \(q \subseteq r\), \(\hasty{\Delta}{p}{a}{A}{r}\), then \(\hasty{\Gamma}{p}{a}{A}{q}\)
    \item If \(\cwk{\Gamma}{\Delta}\), \(\haslb{\Delta}{t}{\ms{L}}\), then \(\haslb{\Gamma}{t}{\ms{L}}\)
    \item If \(\lwk{\ms{L}}{\ms{K}}\), \(\haslb{\Gamma}{t}{\ms{L}}\) then \(\haslb{\Gamma}{t}{\ms{K}}\)
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\begin{figure}
  \begin{center}        
    \begingroup
    \renewcommand{\arraystretch}{1.5}
    \setlength{\tabcolsep}{2em}
    \begin{tabular}{rl}
        \multicolumn{1}{c}{Judgment} & \multicolumn{1}{c}{Meaning} \\ \hline
        \(\issubst{\gamma}{\Theta}{\Gamma}\) &
        ... \\
        \(\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\) &
        ... \\
        \(\mhasty{H}{\Gamma}{p}{\mhole{a}}{A}{q}\) &
        ... \\
        \(\mhaslb{H}{\Gamma}{\mhole{t}}{\ms{L}}\) &
        ... \\
        \(\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}}\) &
        ... \\
        \(\isrw{\mc{H}}{I}{H}\) &
        ... \\
    \end{tabular}
    \endgroup
  \end{center}
  \caption{Metatheoretic typing judgements for \isotopessa}
  \Description{Metatheoretic typing judgements for isotope-SSA}
  \label{fig:ssa-meta-judgements}
\end{figure}

\TODO{some text about each metatheoretic judgement}

\begin{figure}
  \begin{gather*}
    \boxed{\gamma: \ms{Var} \to \ms{Expr}}
    \\
    \prftree[r]{\rle{subst-nil}}
      {\issubst{\gamma}{\cdot}{\cdot}}
      \qquad
    \prftree[r]{\rle{subst-cons}}
      {\issubst{\gamma}{\Theta_\Gamma}{\Gamma}}
      {\hasty{\Theta_x}{1}{\gamma(x)}{A}{q}}
      {\tlin{\Theta_x}{q}}
      {\csplits{\Theta}{\Theta_\Gamma}{\Theta_x}}
      {\issubst{\gamma}{\Theta}{\Gamma, \thyp{x}{A}{q}}}
    \\
    \boxed{\mc{L}: \ms{Label} \to \ms{Expr} \to \ms{Block} \text{ s.t. for fresh } x, [a/x]\mc{L}(\lbl{\ell}, x) = \mc{L}(\lbl{\ell}, a)}
    \\
    \prftree[r]{\rle{lb-subst-nil}}
    {\lbsubst{\mc{L}}{\cdot}{\ms{K}}}
      \qquad
    \prftree[r]{\rle{lb-subst-cons}}
      {\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}
      {\haslb{\Gamma, \thyp{x}{A}{}}{\mc{L}(\lbl{\ell}, x)}{\ms{K}}}
      {\lbsubst{\mc{L}}{\ms{L}, \llhyp{\ell}{\Gamma}{A}}{\ms{K}}}
  \end{gather*}
  \caption{
    Typing rules for \isotopessa substitutions. 
    We generally assume that for all but finitely many variables \(x\) and labels \(\lbl{\ell}\), \(\gamma(x) = x\) and \(\mc{L}(\lbl{\ell}, x) = \lbrb{\ell}{x}\).
  }
  \Description{Typing rules for isotope-SSA substitutions}
  \label{fig:ssa-subst-typing}
\end{figure}

\TODO{some text about substitution}

\begin{figure}
  \begin{gather*}
    % \restrictsubst{\gamma}{\Gamma}(x) 
    %   =
    %   (\ms{if}\; x \in \Gamma
    %   \;\ms{then}\;\gamma(x)
    %   \;\ms{else}\;x)
    % \\
    \stmtletsubst{\substctx{\gamma}{\cdot}}{t} = t
    \qquad
    \stmtletsubst{\substctx{\gamma}{\Gamma, x: A^q}}{t} 
      = \letstmt{x}{\gamma(x)}{\stmtletsubst{\substctx{\gamma}{\Gamma}}{t}}
    \qquad
    \exprletsubst{\cdot}{e} = e
    \qquad
    \exprletsubst{\substctx{\gamma}{\Gamma, x: A^q}}{e} 
      = \letstmt{x}{\gamma(x)}{\substctx{\gamma}{\Gamma}}
    \\
    \substlbs{\gamma}{\cdot}(\lbl{\ell}, x) = \lbrb{\ell}{x}
    \qquad
    \substlbs{\gamma}{\ms{L}, \llhyp{\ell}{\Gamma}{A}}(\lbl{k}, x)
      = 
      (\ms{if}\; \lbl{k} = \lbl{\ell} 
      \;\ms{then}\;\stmtletsubst{\substctx{\gamma}{\Gamma}}{\lbrb{\ell}{x}}
      \;\ms{else}\;\substlbs{\gamma}{\ms{L}}(\lbl{\ell}, x))
    \\
    [\mc{L}](\lbrb{\ell}{a}) = \mc{L}(\lbl{\ell}, a)
    \qquad
    [\mc{L}]\ite{e}{s}{t} = \ite{e}{[\mc{L}]s}{[\mc{L}]t}
    \\
    [\mc{L}](\letstmt{x}{a}{t}) = (\letstmt{x}{a}{[\mc{L}]t})
    \qquad
    [\mc{L}](\letstmt{(x, y)}{a}{t}) = (\letstmt{(x, y)}{a}{[\mc{L}]t})
    \\
    [\mc{L}]\ewhere{t}{L} = \ewhere{[\mc{L}]t}{[\mc{L}]L}
    \\
    [\mc{L}]\cdot = \cdot
    \qquad
    [\mc{L}](\lwbranch{\ell}{x: A}{t})
    = (\lwbranch{\ell}{x: A}{[\mc{L}]t})
  \end{gather*}
  \caption{Operations on \isotopessa substitutions.}
  \Description{Operations on isotope-SSA substitutions}
  \label{fig:ssa-subst-ops}
\end{figure}

\TODO{some text about substitution operations}

\begin{lemma}[Substitution Splitting] 
  If \(\csplits{\Gamma}{\Delta}{\Xi}\) and \(\issubst{\gamma}{\Theta}{\Gamma}\), then there exist \(\Theta_\Delta\), \(\Theta_\Xi\) such that:
  \begin{itemize}
    \item \(\csplits{\Theta}{\Theta_\Delta}{\Theta_\Xi}\)
    \item \(\issubst{\gamma}{\Theta_\Delta}{\Delta}\)
    \item \(\issubst{\gamma}{\Theta_\Xi}{\Xi}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix?}

\TODO{some text about substitution weakening}

\begin{theorem}[Substitution] 
  Given \(\issubst{\gamma}{\Theta}{\Gamma}\),
  \begin{itemize}
    \item If \(\hasty{\Gamma}{p}{a}{A}{q}\), then \(\hasty{\Theta}{p}{[\gamma]a}{A}{q}\)
    \item If \(\haslb{\Gamma}{t}{\ms{L}}\), then there exists \(\ms{K}\) such that \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\) and \(\haslb{\Theta}{[\gamma]t}{\ms{K}}\)
    \item If \(\lhaslb{\ms{W}}{L}{\ms{L}}\), then there exists \(\ms{K}, \ms{W}'\) such that 
    \begin{itemize}
      \item \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\) 
      \item \(\lbsubst{\substlbs{\gamma}{\ms{W}'}}{\ms{W}}{\ms{W}'}\) 
      \item \(\lhaslb{\ms{W}'}{[\gamma]L}{\ms{K}}\)
    \end{itemize}
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about substitution}

\begin{theorem}[Label Substitution] 
  Given \(\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\), 
  \begin{itemize}
    \item For all \(\haslb{\Gamma}{t}{\ms{L}}\), \(\haslb{\Gamma}{[\mc{L}]t}{\ms{K}}\)
    \item For all \(\lhaslb{\ms{W}}{L}{\ms{L}}\), \(\lhaslb{\ms{W}}{[\mc{L}]L}{\ms{K}}\)
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about label substitution}

\begin{figure}
  \begin{grammar}
    <\(\mhole{a}, \mhole{b}, \mhole{c}, \mhole{e}\)> ::= \(\lhole{X}\)
    \;|\; \(x\) 
    \;|\; \(f\;\mhole{a}\)
    \;|\; \((\mhole{a}, \mhole{b})\) 
    \;|\; \(()\) 
    \;|\; \(\ctt\) 
    \;|\; \(\cff\)
    \;|\; \(\letexpr{x}{\mhole{a}}{\mhole{e}}\)
    \;|\; \(\letexpr{(x, y)}{\mhole{a}}{\mhole{e}}\)
    % \alt \(\lbsplice{\ell}{x: A}{\mhole{t}}\)

    <\(\mhole{s}, \mhole{t}\)> ::= \(\lhole{T}\) 
    \;|\; \(\lbrb{\ell}{\mhole{a}}\) 
    \;|\; \(\ite{\mhole{e}}{\mhole{s}}{\mhole{t}}\)
    \;|\; \(\letstmt{x}{\mhole{a}}{\mhole{t}}\)
    \;|\; \(\letstmt{(x, y)}{\mhole{a}}{\mhole{t}}\)
    \;|\; \(\ewhere{\mhole{t}}{\mhole{L}}\)

    <\(\mhole{L}\)> ::= \(\lhole{W}\) \;|\; \(\cdot\) \;|\; \(\lwbranch{\ell}{x: A}{\mhole{t}}, \mhole{L}\)

    <\(H\)> ::= \(\cdot\) 
    \;|\; \(H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}\)
    \;|\; \(H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}\)
    \;|\; \(H, \cfghole{\lhole{W}}{\ms{L}}{\ms{K}}\)
  \end{grammar}
  \caption{Grammar for \isotopessa terms and blocks with holes}
  \Description{Grammar for isotope-SSA blocks with holes}
  \label{fig:blocks-with-holes-grammar}
\end{figure}

\TODO{some text about terms with holes}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{hole-tm}}
      {\tyhole{\lhole{X}}{\Delta}{p}{A}{q}}
      {\cwk{\Gamma}{\Delta}}
      {\mhasty{H}{\Gamma}{p}{\lhole{X}}{A}{q}} \qquad
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma}{\thyp{x}{A}{q}}}
      {\mhasty{H}{\Gamma}{p}{x}{A}{q}} \qquad
    \prftree[r]{\rle{app}}
      {f \in \mc{I}_p^q(A, B)}
      {\mhasty{H}{\Gamma}{1}{\mhole{a}}{A}{q}}
      {\mhasty{H}{\Gamma}{p}{f\;\mhole{a}}{B}{q}} \\
    \prftree[r]{\rle{pair}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta}{1}{\mhole{a}}{A}{q}}
      {\mhasty{H}{\Xi}{1}{\mhole{b}}{B}{q}}
      {\mhasty{H}{\Gamma}{p}{(\mhole{a}, \mhole{b})}{A \otimes B}{q}} \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma}{\cdot}}
      {\mhasty{H}{\Gamma}{p}{()}{\mb{1}}{q}} \qquad
    \prftree[r]{\rle{true}}
      {\cwk{\Gamma}{\cdot}}
      {\mhasty{H}{\Gamma}{p}{\ctt}{\mb{2}}{q}} \qquad
    \prftree[r]{\rle{false}}
      {\cwk{\Gamma}{\cdot}}
      {\mhasty{H}{\Gamma}{p}{\cff}{\mb{2}}{q}} \\
    \prftree[r]{\rle{let}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta, \thyp{x}{A}{}}{p}{\mhole{e}}{B}{q}}
      {\mhasty{H}{\Xi}{1}{\mhole{a}}{A}{q}}
      {\mhasty{H}{\Gamma}{p}{\letexpr{x}{\mhole{a}}{\mhole{e}}}{B}{q}} \qquad
    % \prftree[r]{\rle{blk}}
    %   {\mhaslb{H}{\Gamma}{\mhole{t}}{\llhyp{\ell}{\cdot}{A}}}
    %   {\mhasty{H}{\Gamma}{0}{\lbsplice{\ell}{A}{\mhole{t}}}{A}{\varnothing}} 
      \\
    \prftree[r]{\rle{let2}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{p}{\mhole{e}}{C}{q}}
      {\mhasty{H}{\Xi}{1}{\mhole{a}}{A \otimes B}{q}}
      {\mhasty{H}{\Gamma}{p}{\letexpr{(x, y)}{\mhole{a}}{\mhole{e}}}{C}{q}}
  \end{gather*}
  \caption{Typing rules for \isotopessa terms with holes}
  \Description{Typing rules for isotope-SSA terms with holes}
  \label{fig:terms-with-holes-typing}
\end{figure}

\TODO{some text about term with hole typing rules}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{hole-blk}}
      {\blkhole{\lhole{T}}{\Delta}{\ms{L}} \in H}
      {\cwk{\Gamma}{\Delta}}
      {\mhaslb{H}{\Gamma}{\lhole{T}}{\ms{L}}} 
      \qquad
    \prftree[r]{\rle{br}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\lwk{\llhyp{\ell}{\Delta}{A}}{\ms{L}}}
      {\mhasty{H}{\Xi}{1}{\mhole{a}}{A}{\tint}}
      {\mhaslb{H}{\Gamma}{\lbrb{\ell}{\mhole{a}}}{\ms{L}}} 
      \\
    \prftree[r]{\rle{ite}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta}{1}{\mhole{e}}{\mb{2}}{\tint}}
      {\mhaslb{H}{\Xi}{\mhole{s}}{\ms{L}}}
      {\mhaslb{H}{\Xi}{\mhole{t}}{\ms{L}}}
      {\mhaslb{H}{\Gamma}{\ite{\mhole{e}}{\mhole{s}}{\mhole{t}}}{\ms{L}}} \\
    \prftree[r]{\rle{let-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhaslb{H}{\Delta, \thyp{x}{A}{}}{\mhole{t}}{\ms{L}}}
      {\mhasty{H}{\Xi}{0}{\mhole{a}}{A}{q}}
      {\mhaslb{H}{\Gamma}{\letstmt{x}{\mhole{a}}{\mhole{t}}}{\ms{L}}} \\
    \prftree[r]{\rle{let2-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhaslb{H}{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{\mhole{t}}{\ms{L}}}
      {\mhasty{H}{\Xi}{0}{\mhole{a}}{A \otimes B}{q}}
      {\mhaslb{H}{\Gamma}{\letstmt{(x, y)}{\mhole{a}}{\mhole{t}}}{\ms{L}}} \\
    \prftree[r]{\rle{where}}
      {\mhaslb{H}{\Gamma}{\mhole{t}}{\ms{L}}}
      {\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}}}
      {\mhaslb{H}{\Gamma}{\ewhere{\mhole{t}}{\mhole{L}}}{\ms{K}}} 
      \qquad
    \prftree[r]{\rle{hole-cfg}}
      {\cfghole{\lhole{W}}{\ms{L}}{\ms{K}} \in H}
      {\lwk{\ms{M}}{\ms{K}}}
      {\mlhaslb{\ms{L}}{H}{\lhole{W}}{\ms{K}}}
      \\
    \prftree[r]{\rle{nil-br}}
      {\mlhaslb{H}{\ms{L}}{\cdot}{\ms{L}}} \qquad
    \prftree[r]{\rle{cons-br}}
      {\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      {\mhaslb{H}{\Gamma, \thyp{x}{A}{}}{\mhole{t}}{\ms{L}}}
      {\mlhaslb{H}{\ms{L}}{\mhole{L}, \lwbranch{\ell}{x: A}{\mhole{t}}}{\ms{K}}}
  \end{gather*}
  \caption{Typing rules for \isotopessa blocks with holes}
  \Description{Typing rules for isotope-SSA blocks with holes}
  \label{fig:blocks-with-holes-typing}
\end{figure}

\TODO{some text about block with hole typing rules}

\begin{figure}
  \begin{gather*}
    \boxed{H: \ms{Hole} \to \ms{MExpr} \sqcup \ms{MBlock} \sqcup \ms{MCfg}}
    \\
    \prftree[r]{\rle{rw-nil}}
      {\isrw{\mc{H}}{H}{\cdot}}
    \qquad
    \prftree[r]{\rle{rw-tm}}
      {\isrw{\mc{H}}{I}{H}}
      {\mhasty{I}{\Gamma}{p}{\mc{H}(\lhole{X})}{A}{q}}
      {\isrw{\mc{H}}{I}{H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}}}
    \\
    \prftree[r]{\rle{rw-blk}}
      {\isrw{\mc{H}}{I}{H}}
      {\mhaslb{I}{\Gamma}{\mc{H}(\lhole{T})}{\ms{L}}}
      {\isrw{\mc{H}}{I}{H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}}}
    \qquad
    \prftree[r]{\rle{rw-cfg}}
      {\isrw{\mc{H}}{I}{H}}
      {\mlhaslb{I}{\ms{L}}{\mc{H}(\lhole{W})}{\ms{K}}}
      {\isrw{\mc{H}}{I}{H, \cfghole{\lhole{L}}{\ms{L}}{\ms{K}}}}
  \end{gather*}
  \caption{Typing rules for \isotopessa rewrites}
  \Description{Typing rules for isotope-SSA rewrites}
  \label{fig:rewrite-typing}
\end{figure}

\TODO{some text about rewrite typing rules}

\begin{theorem}[Rewriting]
  Given \(\isrw{\mc{H}}{H}{I}\), we have
  \begin{itemize}
    \item If \(\mhasty{H}{\Gamma}{p}{a}{A}{q}\), then \(\mhasty{I}{\Gamma}{p}{[\mc{H}]a}{A}{q}\)
    \item If \(\mhaslb{H}{\Gamma}{t}{\ms{L}}\), then \(\mhaslb{I}{\Gamma}{[\mc{H}]t}{\ms{L}}\)
  \end{itemize}
  
  Furthermore, we have that 
  \begin{itemize}
    \item \(\mhasty{\cdot}{\Gamma}{p}{a}{A}{q} \iff \hasty{\Gamma}{p}{a}{A}{q}\)
    \item \(\mhaslb{\cdot}{\Gamma}{t}{\ms{L}} \iff \haslb{\Gamma}{t}{\ms{L}}\)
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about rewriting}

\section{SSA Semantics}

\label{sec:semantics}

\TODO{intro text}

\subsection{Substructural Categories}

\TODO{intro text}

\begin{definition}[Binoidal Category] \
  \TODO{this}
\end{definition}

\begin{definition}[Premonoidal Category] \
  \TODO{this}
\end{definition}

\TODO{text}

\begin{definition}[Substructural (Pre)monoidal Category]
  A \textbf{substructural (pre)monoidal category} is a tuple \((\mc{C}, \mc{A}, \mc{R})\) where:
  \begin{itemize}
    \item \(\mc{C}\) is a family of categories \(\mc{C}^q\) parametrized by subsets \(q \subseteq \{\ms{a}, \ms{r}\}\) such that
    \begin{itemize}
      \item For all \(q \subseteq q'\), \(\mc{C}^{q'}\) is a wide subcategory of \(\mc{C}^q\), and in particular all object sets \(|\mc{C}^q|\) are the same. We will write this set as \(|\mc{C}|\)
      \item All \(\mc{C}^q\) share symmetric (pre)monoidal structure, and are individually closed under the tensor products of morphisms
      \item \(\mc{C}^{q \cap q'} = \mc{C}^q \cap \mc{C}^{q'}\)
    \end{itemize}
    \item \(\mc{A} \subseteq |\mc{C}|\) is a set of \textbf{affine} objects closed under tensor products, such that
    \begin{itemize}
      \item \(\mb{1} \in \mc{A}\)
      \item Every \(A\) in \(\mc{A}\) is equipped with a central morphism \(\ms{drop}(A): \mc{C}^{\{\ms{a}, \ms{r}\}}(A, \mb{1})\)
      \item \(\forall A, B \in \mc{A}, \ms{drop}(A \otimes B) = \ms{drop}(A) \otimes \ms{drop}(B);\lambda_I\)
      \item \(\forall A, B \in \mc{A}, \forall f: \mc{C}^{\{\ms{a}\}}(A, B), f;\ms{drop}(B) = \ms{drop}(A)\)
    \end{itemize}
    \item \(\mc{R} \subseteq |\mc{C}|\) is a set of \textbf{relevant} objects closed under tensor products, such that
    \begin{itemize}
      \item \(\mb{1} \in \mc{R}\)
      \item Every \(A\) in \(\mc{R}\) is equipped with a central morphism \(\ms{split}(A): \mc{C}^{\{\ms{a}, \ms{r}\}}(A, A \otimes A)\)
      \item \(\forall A, B \in \mc{R}, \ms{split}(A \otimes B) = \ms{split}(A) \otimes \ms{split}(B);\alpha;A \otimes \sigma_{A, B} \otimes B;\alpha\)
      \item Associativity: \(\forall A \in \mc{R}, \ms{split}(A);\ms{split}(A) \otimes A;\alpha = \ms{split}(A);A \otimes \ms{split}(A)\)
      \item Commutativity: \(\forall A \in \mc{R}, \ms{split}(A);\sigma = \ms{split}(A)\)
      \item Comonoid: \(\forall A \in \mc{A} \cap \mc{R}, \ms{split}(A);A \otimes \ms{drop}(A) = \rho_A^{-1} \quad \ms{split}(A);\ms{drop}(A) \otimes A = \lambda_A^{-1}\)
      \item \(\forall A, B \in \mc{R}, \forall f: \mc{C}^{\{\ms{r}\}}(A, B), f;\ms{split}(B) = \ms{split}(A);f \ltimes f = \ms{split}(A);f\rtimes f\)
    \end{itemize}
  \end{itemize}
  We call the morphisms in \(\mc{C}^{\{\ms{a}\}}\) \textbf{affine}, the morphisms in \(\mc{C}^{\{\ms{r}\}}\) \textbf{relevant}, and the morphisms in \(\mc{C}^{\{\ms{a}, \ms{r}\}}\) \textbf{pure} or \textbf{intuitionistic}. We call the morphisms in \(\mc{C}^\varnothing\) but not necessarily in any of the other \(\mc{C}^q\) \textbf{linear}. We call a substructural \textit{monoidal} category a \textbf{substructural Cartesian category} if \(\mc{A} = \mc{R} = |\mc{C}|\), in which case \(\mc{C}^{\{\ms{a}, \ms{r}\}}\) is Cartesian.
\end{definition}
\TODO{Define \(\mc{C}^{\ms{a}}, \mc{C}^{\ms{r}}\) syntax? Make lattice generated by syntax?}
A simple example of a substructural Cartesian category is the category of relations \(\ms{Rel}\), viewed as the Kleisli category of the power-set monad with morphisms of the form \(\ms{Rel}(A, B) = A \to \mc{P}(B)\). In particular, we can define:
\begin{equation}
  \begin{aligned}
    \ms{Rel}^\varnothing(A, B) 
    &= \ms{Rel}(A, B) 
    &&= A \to \mc{P}(B) \\
    \ms{Rel}^{\{\ms{a}\}}(A, B) 
    &= \{R \in \ms{Rel}(A, B) \mid \forall a, |R(a)| \geq 1\} 
    &&= A \to \mc{P}^+(B) \\
    \ms{Rel}^{\{\ms{r}\}}(A, B) 
    &= \{R \in \ms{Rel}(A, B) \mid \forall a, |R(a)| \leq 1\} 
    &&= A \to \ms{Option}(B) \\
    \implies \ms{Rel}^{\{\ms{a}, \ms{r}\}}(A, B) 
    &= \{R \in \ms{Rel}(A, B) \mid \forall a, |R(a)| = 1\} 
    &&= A \to B
  \end{aligned}
\end{equation}
Here, \(\ms{split}(A)\) is just the copy operator \(a \mapsto (a, a)\) and \(\ms{drop}(A)\) the deletion operator \(a \mapsto ()\); it is quite trivial to prove that these lie in \(\ms{Rel}^{\{\ms{a}, \ms{r}\}}\), being functions, and that they satisfy the axioms of a commutative comonoid, as desired. 

Note that we cannot simply have \(\ms{Rel}^{\{\ms{a}\}} = \ms{Rel}\), since, for any morphism \(R: \ms{Rel}(A, B)\) such that \(\exists a \in A, R(a) = \varnothing\), we have
\begin{equation}
  (R;\ms{drop}(B))(a) = \varnothing \neq \ms{drop}(A)(a) = \{()\}
\end{equation}
We will see that this corresponds to the fact that the following programs are not semantically equal
\begin{equation}
  \ms{let}\;x = \ms{loop}(); e \not\simeq e \qquad \text{where} \qquad x \notin \ms{fv}(e)
\end{equation}
Similarly, we cannot simply have \(\ms{Rel}^{\{\ms{r}\}} = \ms{Rel}\), since, for any morphism \(R: \ms{Rel}(A, B)\) such that \(\exists a \in A, |R(a)| \supseteq \{b_0, b_1\}\) where \(b_0 \neq b_1\), we have that
\begin{equation}
  (R;\ms{split}(B))(a) = \{(b, b) \mid b \in R(a)\} \neq (\ms{split}(A);R)(a) = R(a) \times R(a) 
\end{equation}
since only the left-hand side contains the pair \((b_0, b_1)\), this corresponding to the fact that the following programs are not semantically equal
\begin{equation}
  \ms{let}\;x = \ms{rand}(); (x, x) \not\simeq (\ms{rand}(), \ms{rand}())
\end{equation}
To get a substructural premonoidal category, we can apply the state monad transformer to the power set monad to obtain the Kleisli category with morphisms of the form \(\ms{Set}_{\ms{St}\;\mc{P}\;S}(A, B) = A \to S \to \mc{P}(B \times S)\). Once again, it is clear that all objects have split and drop morphisms inherited from \(\ms{Set}\), and therefore are affine and relevant

\begin{definition}[Susbtructural Effectful Category]
  A \textbf{substructural effectful category} \(\mc{C}\) consists of
  \begin{itemize}
    \item A substructural monoidal category \(\mc{C}_1\); we call the morphisms in this category \textbf{central} or \textbf{linear}
    \item A substructural premonoidal category \(\mc{C}_0\) sharing the same affine and relevant objects as \(\mc{C}_1\)
    \item An identity-on-objects functor \(\upg{\cdot}{}: \mc{C}_1^\varnothing \to \mc{C}_0^\varnothing\) preserving all substructural premonoidal structure, i.e., preserves all symmetries, associators, unitors, drops, and splits and sends \(\mc{C}_1^q\) to \(\mc{C}_0^q\).
    In particular, restricting \(\upg{\cdot}{}\) appropriately makes all \(\mc{C}_1^q \to \mc{C}_0^q\) into effectful categories.
  \end{itemize}
  We define \(\upg{f}{0}\) to be \(\upg{f}{}\) for morphisms in \(\mc{C}_1^q\) and simply \(f\) for morphisms in \(\mc{C}_0\), and \(\upg{f}{1}\) to simply be the identity functor on \(\mc{C}_1^q\).
 
  Morphisms in \(\mc{C}_p^{\{\ms{a}\}}\) are called \textbf{copyable}, morphisms in \(\mc{C}_p^{\{\ms{r}\}}\) are called \textbf{discardable},
  while morphisms in \(\mc{C}_1^{\{\ms{a}\}}, \mc{C}_1^{\{\ms{r}\}}, \mc{C}_1^{\{\ms{a}, \ms{r}\}}\) specifically are called \textbf{affine}, \textbf{relevant}, and \textbf{intuitionistic} or \textbf{pure} respectively.
\end{definition}

We can obtain an example of a substructural effectful category quite easily by, considering the power-set monad above, applying the state transformer to yield the Kliesli category with morphisms of the form \(\mc{C}_0(A, B) = A \to S \to \mc{P}(A \times S)\). Letting \(\mc{C}_1^q = \ms{Rel}^q\) and defining
\(
  \upg{R}{} = \lambda a, s. R(a) \times \{s\}
\), we can verify that this satisfies the axioms of a substructural effectful category.
Note that here the \textit{central} morphisms are precisely those which do not read from or write to the state, and therefore which commute with all other morphisms.

We can further use this example to get a substructural \textit{monoidal} category by considering a primitive form of separation logic: let's introduce a grammar of predicates \(\varphi, \psi ::= \top, \ms{S}, \bot\) for programs which cannot access state, can access state, and are invalid, respectively. The separating conjunction operator on these predicates is then given by
\begin{equation}
  \top * \varphi = \varphi * \top = \varphi
  \qquad
  \bot * \varphi = \varphi * \bot = \bot
  \qquad
  \ms{S} * \ms{S} = \bot
\end{equation}
We'll then define a category \(\ms{SRel}\) with objects of the form \((A, \varphi)\) and morphisms
\begin{equation}
  \begin{gathered}
    \boxed{
      \ms{SRel}((A, \varphi), (B, \psi)) 
      \subseteq A \to \ms{S} \to \mc{P}(A \times S) 
    }
    \\
    \begin{aligned}
      \ms{SRel}((A, \top), (B, \top)) &= \{f \in A \to S \to \mc{P}(A \times S) \mid \exists g. f = \lambda a, s. g(a) \times \{s\}\} \\
      \ms{SRel}((A, \ms{S}), (B, \ms{S})) &= A \to S \to \mc{P}(A \times S) \\
      \ms{SRel}((A, \varphi), (B, \psi)) &= \{\lambda a, s. \varnothing\} \quad \text{otherwise}
    \end{aligned}
  \end{gathered}
\end{equation}
Note that it is precisely the \textit{central} morphisms \(\ms{C}_0(A, B)\) which lie in \(\ms{SRel}((A, \top), (B, \top))\). We can then define the tensor product on objects as \((A, \varphi) \otimes (B, \psi) = (A \otimes B, \varphi * \psi)\), and, for \(f \in \mathsf{SRel}((A, \varphi), (B, \psi))\), and tensor product functors
\begin{equation}
  \begin{aligned}
  f \otimes (C, \phi) &= f \otimes C,
  & (C, \phi) \otimes f &= C \otimes f
  && \text{if}\; \varphi * \phi \neq \bot, \psi * \phi \neq \bot \\
  f \otimes (C, \phi) &= \lambda a, s. \varnothing,
  & (C, \phi) \otimes f &=  \lambda a, s. \varnothing
  && \text{otherwise}
  \end{aligned} 
\end{equation}
Lifting associators, unitors, and symmetries from \(\mc{C}_0\) in the obvious manner (setting them to \(\lambda a, s. \varnothing\) where necessary), we can verify that \(\ms{SRel}\) is a \textit{premonoidal} category. we can see that it is in fact \textit{monoidal} by nothing that, for any \(f, g\), \(f \ltimes g = f \rtimes g\) since either \(f\) is central, \(g\) is central, or their product is the empty morphism \(\lambda a, s. \varnothing\). Hence, to get a \textit{substructural} monoidal category, we simply need to define:
\begin{equation}
  \begin{gathered}
  \ms{Aff}(\ms{SRel}) = \ms{Rel}(\ms{SRel}) = \{(A, \top) | A \in \ms{Set}\} \neq |\ms{SRel}|
  \\
  \begin{aligned}
    \ms{SRel}^\varnothing((A, \phi), (B, \psi))
    &= \ms{SRel}((A, \phi), (B, \psi)) \\
    \ms{SRel}^{\{\ms{a}\}}((A, \phi), (B, \psi)) 
    &= \{f \in \ms{SRel}((A, \phi), (B, \psi)) \mid \forall a, s. |f(a, s)| \geq 1 \lor \phi \neq \psi \lor \phi = \bot \} \\
    \ms{SRel}^{\{\ms{r}\}}((A, \phi), (B, \psi)) 
    &= \{f \in \ms{SRel}((A, \phi), (B, \psi)) \mid \forall a, s. |f(a, s)| \leq 1 \lor \phi \neq \psi \lor \phi = \bot \} \\
    \implies \ms{SRel}^{\{\ms{a}, \ms{r}\}}((A, \phi), (B, \psi)) 
    &= \{f \in \ms{SRel}((A, \phi), (B, \psi)) \mid \forall a, s. |f(a, s)| = 1 \lor \phi \neq \psi \lor \phi = \bot \} \\
  \end{aligned}
  \end{gathered}
\end{equation}
We can verify that the associators, unitors, and symmetry lie in \(\ms{SRel}^{\{\ms{a}, \ms{r}\}}\) and that all other desired axioms are satisfied.

\TODO{relate separation logic trick to \cite{promonad}, \cite{linear-state-usage}, \cite{mellies-ftrs}}

\TODO{clean up, and generalize to arbitrary premonoidal categories (w/ initial object? how to deal w/ coproducts?)}

In general, \textit{every} premonoidal category \(\mc{C}\) can be viewed a substructural premonoidal category, with \(\mc{C}^\varnothing = \mc{C}\) and \(\mc{C}^{\{\ms{a}, \ms{r}\}}, \mc{C}^{\{\ms{a}\}}, \mc{C}^{\{\ms{r}\}}\) the subcategory consisting only of the associators, unitors, and symmetry, and only the identity object considered affine and relevant. On the other extreme, every \textit{Cartesian} category \(\mc{C}\) can be viewed as a substructural Cartesian category with all morphisms both relevant and affine; in fact, this is the case \textit{if and only if} a category is Cartesian, hence the term "substructural Cartesian category."

We can also deduce the following:
\begin{proposition}
  If \(\mc{C}\) is a substructural monoidal category then the Kleisli category \(\mc{C}_{\mb{T}}\) is a substructural premonoidal category with:
  \begin{itemize}
    \item \(\ms{Aff}(\mc{C}_{\mb{T}}) = \ms{Aff}(\mc{C})\), \(\ms{Rel}(\mc{C}_{\mb{T}}) = \ms{Rel}(\mc{C})\)
    \item \(\mc{C}_{\mb{T}}^q(A, B) = \upg{\mc{C}^q(A, B)}{}\), where \(\upg{f}{} = f;\eta\)
    \item Drops \(\upg{\ms{drop}(A)}{}\) and splits \(\upg{\ms{split}(A)}{}\)
  \end{itemize} 
  In particular, \(\upg{\cdot}{}: \mc{C} \to \mc{C}_{\mb{T}}\) is a substructural effectful category.
\end{proposition}

\TODO{work into text?}

\subsection{Distributivity}

\begin{definition}[Distributive (pre)monoidal category] 
  A \textbf{distributive (pre)monoidal category} is a (pre)monoidal category with all finite coproducts equipped with a natural family of central isomorphisms (the \textbf{distributor}) \(\delta_{A, B, C}: (A + B) \otimes C \simeq A \otimes C + B \otimes C\). This isomorphism is subject to rather complex coherence conditions, worked out in full for the more general case of \textit{rig categories} in \cite{laplaza-distributivity}, but for our purposes we will only make use of the following:
  \begin{equation*}
    \delta_{A, B, C}^{-1} = [\iota_0 \otimes C, \iota_1 \otimes C] 
    \qquad
    \sigma^+_{A, B} \otimes C;\delta_{B, A, C} = \delta_{A, B, C};\sigma^+_{A \otimes C, B \otimes C}
  \end{equation*}
  Note in particular that this implies that \(\iota_i \otimes C;\delta_{A, B, C} = \iota_i\). A substructural (pre)monodial category is \textbf{distributive} if it is distributive as a (pre)monoidal category, and its distributor is \textit{pure}. A substructural effectful category \(\mc{C}\) is \textbf{distributive} if \(\mc{C}_0\) is distributive (as a substructural (pre)monoidal category).
\end{definition}
Many (pre)monoidal categories are distributive, including of course \(\ms{Set}\), but also categories which can be derived from monads on more primitive categories such as \(\ms{PFun}\) and \(\ms{Rel}\), as can be deduced from the following proposition:
\begin{proposition}
  If \(\mc{C}\) is a distributive substructural monoidal category and \(\mb{T}\) is a strong monad on \(\mc{C}\), then the Kleisli category \(\mc{C}_{\mb{T}}\) is a distributive substructural effectful category (with affine and relevant objects and morphisms inherited from \(\mc{C}\))
\end{proposition}
\begin{proof}
  Let \(\delta_{A, B, C}: \mc{C}((A + B) \otimes C, A \otimes C + B \otimes C)\) denote \(\mc{C}\)'s distributor. We will write composition in \(\mc{C}\) as "\(;\)" and composition in the Kleisli category \(\mb{T}\) as "\(\gg\)".
  We will show that
  \(\upg{\delta_{A, B, C}}{} = \delta_{A, B, C};\ms{pure}: \mc{C}_{\mb{T}}((A + B) \otimes C, A \otimes C + B \otimes C)\) satisfies the desired properties of a distributor. In particular, it is:
  \begin{itemize}
    \item Central: this follows immediately from being the image of a pure morphism
    \item Affine: \(\upg{\delta}{} \gg \upg{\ms{drop}}{} = \upg{(\delta;\ms{drop})}{} = \upg{\ms{drop}}{}\)
    \item Relevant: \(\upg{\delta}{} \gg \upg{\ms{split}}{} = \upg{(\delta;\ms{split})}{} = \upg{(\ms{split};\delta \otimes \delta)}{} = \upg{\ms{split}}{} \gg \upg{\delta}{} \otimes \upg{\delta}{}\)
    \item Left inverse: \(\upg{\delta}{} \gg \upg{[\iota_0 \otimes C, \iota_1 \otimes C]}{} = \upg{\delta;[\iota_0 \otimes C, \iota_1 \otimes C]}{} = \ms{id}\)
    \item Right inverse: \(\upg{[\iota_0 \otimes C, \iota_1 \otimes C]}{} \gg \upg{\delta}{} = \upg{[\iota_0 \otimes C, \iota_1 \otimes C];\delta}{} = \ms{id}\)
    \item Symmetric: \(\upg{\sigma^+}{} \otimes C \gg \upg{\delta}{} = \upg{\sigma^+ \otimes C;\delta}{} = \upg{\delta;\sigma^+}{} = \upg{\delta}{} \gg \upg{\sigma^+}{}\)
  \end{itemize}
\end{proof}

\TODO{text}

\subsection{Elgot Categories}

\TODO{text}

\begin{definition}[Elgot category] 
  An \textbf{Elgot category} is a category \(\mc{C}\) with coproducts equipped with an operator \(\cdot^\dagger: \mc{C}(A, B + A) \to \mc{C}(A, B)\) satisfying the following properties:
  \begin{itemize}
    \item \textbf{Fixpoint:} \(f;[\ms{id}, f^\dagger] = f^\dagger\)
    \item \textbf{Naturality:} \((f;g + \ms{id})^\dagger = f^\dagger;g\)
    \item \textbf{Codiagonal:} \(\forall f \in \mc{C}(A, (B + A) + A), (f^\dagger)^\dagger = (f;[\ms{id}, \iota_1])^\dagger\)
    \item \textbf{Uniformity:}
    \(
      h;f = g;\ms{id} + h \implies h;f^\dagger = g^\dagger
    \)
  \end{itemize}
  A monad \(\mb{T}\) on \(\mc{C}\) such that its Kleisli cateogry \(\mc{C}_{\mb{T}}\) is Elgot is called an \textbf{Elgot monad}.
\end{definition}
\TODO{why do these matter? they show up in the proofs, but...}
Some important properties which hold for all Elgot categories include:
\begin{itemize}
  \item \textbf{Dinaturality:} \((g;[\iota_0, h])^\dagger = g;[\ms{id}, (h;[\iota_0, g])^\dagger]\)
  \item \textbf{Squaring:} \((f;[\iota_0, f])^\dagger = f^\dagger\)
\end{itemize}
Proofs can be found in Lemma 31 of \cite{goncharov-squaring}.

\TODO{Hyland and Hasegawa traces?}

\TODO{intuition? Can draw diagrams, but those take up space}

\begin{proposition}
  If \(\mb{T}\) is an Elgot monad on \(\ms{Set}\), then \(\ms{StateT}\;\mb{T}\;S = \lambda A. S \to \ms{T}(A \times S)\), \(\ms{ReaderT}\;\mb{T}\;S = \lambda A. S \to \ms{T}(A)\), and \(\ms{WriterT}\;\mb{T}\;S = \lambda A. \ms{T}(A \times S)\) are all Elgot
\end{proposition}

\subsection{Denotational Semantics}

\TODO{make aff and rel syntax nicer/more consistent here? Subcategory syntax would be nice for lemmas and just coherence.}

We're now ready to give a semantics for an \isotopessa dialect with a set of types \(\mc{T}\) and instructions \(\mc{I}\). We'll need:
\begin{itemize}
  \item A \textit{substructural effectful category} \(\mc{C} = \mc{C}_1 \to \mc{C}_0\) such that \(\mc{C}_0\) is \textit{distributive} and \textit{Elgot}, equipped with
  \item A function \(\ms{base}(X)\) from base types \(X \in \mc{T}\) to objects in \(|\mc{C}|\), such that \(\ms{a} \in \ms{lin}(X) \implies \ms{base}(X) \in \ms{Aff}(\mc{C})\) and \(\ms{r} \in \ms{lin}(X) \implies \ms{base}(X) \in \ms{Rel}(\mc{C})\)
  \item A function \(\ms{inst}(f)\) from instructions \(f \in \mc{I}_p^q(A, B)\) to morphisms in \(\mc{C}_p^q(\dnt{A}, \dnt{B})\)
\end{itemize}
We begin by giving a semantics for types and contexts in terms of objects in \(|\mc{C}|\) in Figure \ref{fig:ssa-type-semantics}; this allows us to give a semantics for structural judgements in Figure \ref{fig:ssa-structural-semantics}.

\TODO{some text about what the semantics actually are...}

We can now give a semantics for terms in Figure \ref{fig:ssa-term-semantics} followed by a semantics for blocks and label-sets in Figure \ref{fig:ssa-block-semantics}.

\TODO{ditto}

\TODO{rename blocks to statements? label-sets to CFGs?}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{A}}: |\mc{C}| \\
    \dnt{X} = \ms{base}(X) 
    \qquad
    \dnt{\mb{1}} = \mb{1}
    \qquad
    \dnt{\mb{2}} = \mb{2} = \mb{1} + \mb{1}
    \qquad \dnt{A \otimes B} = \dnt{A} \otimes \dnt{B} \\
    \boxed{\dnt{\Gamma}}: |\mc{C}| \\
    \dnt{\cdot} = \mb{1} \qquad 
    \dnt{\Gamma, \thyp{x}{A}{q}} = \dnt{\Gamma} \otimes \dnt{A} \\
    \boxed{\dnt{\ms{L}}}: |\mc{C}| \\
    \dnt{\cdot} = \mb{0} \qquad
    \dnt{\ms{L}, \llhyp{\ell}{\Gamma}{A}} = 
      \dnt{\ms{L}} + \dnt{\Gamma} \otimes \dnt{A}
  \end{gather*}
  \caption{Semantics for \isotopessa types and contexts}
  \Description{Semantics for isotope-SSA types and contexts}
  \label{fig:ssa-type-semantics}
\end{figure}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\tlin{A}{\taff}: \mc{C}_1^\tint(\dnt{A}, \mb{1})}}
      \\
      \dnt{\tlin{A}{\taff}} = \ms{drop}(\dnt{A})
      % \dnt{\tlin{X}{\taff}} = \ms{drop}(X) \qquad
      % \dnt{\tlin{A \otimes B}{\taff}} 
      %   = \dnt{\tlin{A}{\taff}} \otimes \dnt{\tlin{B}{\taff}}
      %   ; \lambda 
      \\
    \boxed{\dnt{\tlin{A}{\trel}}
      : \mc{C}_1^\tint(\dnt{A}, \dnt{A} \otimes \dnt{A})}
      \\
      \dnt{\tlin{A}{\trel}} = \ms{split}(\dnt{A})
      % \dnt{\tlin{X}{\trel}} = \ms{split}(X) \qquad
      % \dnt{\tlin{A \otimes B}{\trel}} = 
      %   \dnt{\tlin{A}{\trel}} \otimes \dnt{\tlin{B}{\trel}}
      %   ;\alpha;\dnt{A} \otimes \sigma \otimes \dnt{B};\alpha 
      \\
    \boxed{\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
      : \mc{C}_1^\tint(\dnt{\Gamma}, \dnt{\Delta} \otimes \dnt{\Xi})}
      \\
    \dnt{\csplits{\cdot}{\cdot}{\cdot}} = \lambda^{-1} \qquad
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta, \thyp{x}{A}{q}}
      {\Xi}} 
      = \dnt{\csplits{\Gamma}{\Delta}{\Xi}} \otimes \dnt{A};\alpha;\dnt{\Delta} \otimes \sigma;\alpha 
      \\
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta}
      {\Xi, \thyp{x}{A}{q}}} 
      = \dnt{\csplits{\Gamma}{\Delta}{\Xi}} \otimes \dnt{A};\alpha 
      \\
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta}
      {\Xi, \thyp{x}{A}{q}}} \
      = \dnt{\Gamma} \otimes \dnt{\tlin{A}{\trel}};
        \alpha;
        \dnt{\Delta} \otimes \sigma \otimes \dnt{A};
        \alpha 
        \\
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta}
      {\Xi}}
      = \dnt{\csplits{\Gamma}{\Delta}{\Xi}}
        \otimes \dnt{\tlin{A}{\taff}}
      ; \rho 
      \\
    \boxed{\dnt{\cwk{\Gamma}{\Delta}}
      : \mc{C}_1^\tint(\dnt{\Gamma}, \dnt{\Delta})} 
      \\
      \dnt{\cwk{\Gamma}{\Delta}} 
      = \dnt{\csplits{\Gamma}{\Delta}{\cdot}};\rho 
      \\
    \boxed{\dnt{\lwk{\ms{L}}{\ms{K}}}
      : \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}})} 
      \\
    \dnt{\lwk{\cdot}{\cdot}} = \ms{id} \qquad
    \dnt{\lwk
      {\ms{L}, \llhyp{\ell}{\Gamma}{A}}
      {\ms{K}, \llhyp{\ell}{\Delta}{A}}}
      = \dnt{\lwk{\ms{L}}{\ms{K}}} + \upg{(\cwk{\Gamma}{\Delta} \otimes \dnt{A})}{} 
      \\
    \dnt{\lwk{\ms{L}}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      = \dnt{\lwk{\ms{L}}{\ms{K}}};\rho_+^{-1}
      ; \dnt{\ms{K}} \oplus 0_{\dnt{\Gamma} \otimes \dnt{A}}
  \end{gather*}
  \caption{Semantics for \isotopessa structural judgements}
  \Description{Semantics for isotope-SSA structural judgements}
  \label{fig:ssa-structural-semantics}
\end{figure}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\hasty{\Gamma}{p}{a}{A}{q}}
      : \mc{C}_p^q(\dnt{\Gamma}, \dnt{A})} 
      \\
    \dnt{\hasty{\Gamma}{p}{x}{A}{q}} 
      = \dnt{\cwk{\Gamma}{\thyp{x}{A}{q}}}
      \qquad
    \dnt{\hasty{\Gamma}{p}{f\;a}{B}{q}}
      = \upg{\dnt{\hasty{\Gamma}{1}{a}{A}{q}}}{p}
      ; \ms{inst}_p(f) 
      \\
    \dnt{\hasty{\Gamma}{p}{(a, b)}{A \otimes B}{q}}
      = \upg{(
        \dnt{\csplits{\Gamma}{\Delta}{\Xi}};
        \dnt{\hasty{\Delta}{1}{a}{A}{q}} \otimes
        \dnt{\hasty{\Xi}{1}{b}{B}{q}}
      )}{\uparrow p} 
      \\
    \dnt{\hasty{\Gamma}{p}{()}{\mb{1}}{q}}
      = \upg{\dnt{\cwk{\Gamma}{\cdot}}}{p} 
      \\
    \dnt{\hasty{\Gamma}{p}{\ctt}{\mb{2}}{q}}
      = \upg{(\dnt{\cwk{\Gamma}{\cdot}};\ctt)}{p}
      \qquad
    \dnt{\hasty{\Gamma}{p}{\cff}{\mb{2}}{q}}
      = \upg{(\dnt{\cwk{\Gamma}{\cdot}};\cff)}{p} 
      \\
    \dnt{\hasty{\Gamma}{p}{\letexpr{x}{a}{e}}{B}{q}}
      = \upg{(
        \dnt{\csplits{\Gamma}{\Delta}{\Xi}}
        ; \dnt{\Delta} \otimes \dnt{\hasty{\Xi}{1}{a}{A}{q}}
      )}{p};\dnt{\hasty{\Delta, \thyp{x}{A}{}}{p}{e}{B}{q}} 
      \\
    \dnt{\hasty{\Gamma}{p}{\letexpr{(x, y)}{a}{e}}{C}{q}}
      = \upg{(
        \dnt{\csplits{\Gamma}{\Delta}{\Xi}}
        ; \dnt{\Delta} \otimes \dnt{\hasty{\Xi}{1}{a}{A \otimes B}{q}}
      )}{p}
      ; 
      \\ \qquad \qquad \qquad \qquad \qquad \alpha
      ; \dnt{\hasty{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{p}{e}{C}{q}}
    %   \\
    % \dnt{\hasty{\Gamma}{0}{\lbsplice{\ell}{A}{t}}{A}{\varnothing}}
    %   = \dnt{\haslb{\Gamma}{t}{\llhyp{\ell}{\cdot}{A}}};\alpha_+
  \end{gather*}
  \caption{Semantics for \isotopessa terms}
  \Description{Semantics for isotope-SSA terms}
  \label{fig:ssa-term-semantics}
\end{figure}

\TODO{some text about term semantics}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\haslb{\Gamma}{t}{\ms{L}}}
      : \mc{C}_0^\varnothing(\dnt{\Gamma}, \dnt{\ms{L}})} \\
    \dnt{\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}}
      = \upg{(\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
      ; \dnt{\Delta} \otimes \dnt{\hasty{\Xi}{1}{a}{A}{\tint}})}
      ; \dnt{\lwk{\llhyp{\ell}{\Delta}{A}}{\ms{L}}} \\
    \dnt{\haslb{\Gamma}{\ite{e}{s}{t}}{\ms{L}}}
      = \upg{(\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
      ; \dnt{\hasty{\Delta}{1}{e}{\mb{2}}{\tint}} \otimes \dnt{\Xi})}
      ; \ms{ite}_{\dnt{\Xi}} ;
      \\ \qquad \qquad \qquad \qquad
      [
        \dnt{\haslb{\Xi}{s}{\ms{L}}}, 
        \dnt{\haslb{\Xi}{t}{\ms{L}}} 
      ]
      \\
    \dnt{\haslb{\Gamma}{\letstmt{x}{a}{t}}{\ms{L}}}
      = \upg{\dnt{\csplits{\Gamma}{\Delta}{\Xi}}}
      ; \dnt{\Delta} \otimes \dnt{\hasty{\Gamma}{0}{a}{A}{q}}
      ; \dnt{\haslb{\Delta, \thyp{x}{A}{}}{t}{\ms{L}}}
      \\
    \dnt{\haslb{\Gamma}{\letstmt{(x, y)}{a}{t}}{\ms{L}}}
      = \upg{\dnt{\csplits{\Gamma}{\Delta}{\Xi}}}
      ; \dnt{\Delta} \otimes \dnt{\hasty{\Gamma}{0}{a}{A \otimes B}{q}}
      ; \alpha
      ; \dnt{\haslb{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{t}{\ms{L}}}
      \\
    \dnt{\haslb{\Gamma}{\ewhere{t}{L}}{\ms{K}}}
      = \dnt{\haslb{\Gamma}{t}{\ms{L}}}
      ; \dnt{\lhaslb{\ms{L}}{L}{\ms{K}}}^\dagger
      \\
    \boxed{\dnt{\lhaslb{\ms{L}}{L}{\ms{K}}}
      : \mc{C}_0^\varnothing(\dnt{\ms{L}}, \dnt{\ms{K}} + \dnt{\ms{L}})}
      \\
    \dnt{\lhaslb{\ms{L}}{L, \lwbranch{\ell}{x: A}{t}}{\ms{K}}}
      = \dnt{\lhaslb{\ms{L}}{L}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      ; [[\iota_0, \dnt{\haslb{\Gamma, \thyp{x}{A}{}}{t}{\ms{L}}}], \iota_1]
      \\
    \dnt{\lhaslb{\ms{L}}{\cdot}{\ms{L}}}
      = \iota_0
  \end{gather*}
  \caption{Semantics for \isotopessa blocks}
  \Description{Semantics for isotope-SSA blocks}
  \label{fig:ssa-block-semantics}
\end{figure}

\TODO{some text about block semantics}

\subsection{Semantic Metatheory}

\TODO{some text about semantic metatheory}

\begin{lemma}[Coherence] \
  \begin{itemize}
    \item Given any two derivations \(D_1: \hasty{\Gamma}{p}{a}{A}{q}\), \(D_2: \hasty{\Gamma}{p}{a}{A}{r}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \haslb{\Gamma}{t}{\ms{L}}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \csplits{\Gamma}{\Delta}{\Xi}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \cwk{\Gamma}{\Delta}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \lwk{\ms{L}}{\ms{K}}\), \(\dnt{D_1} = \dnt{D_2}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix? This is just a trivial induction.}

\TODO{some text about coherence, implicit use above}

\begin{lemma}[Semantic Upgrade]
  For all \(\Gamma, a, A\), if \(\hasty{\Gamma}{1}{a}{A}{q}\), then
  \[\dnt{\hasty{\Gamma}{0}{a}{A}{q}} = \upg{\dnt{\hasty{\Gamma}{1}{a}{A}{q}}}{}\]
\end{lemma}

\TODO{some text about upgrade}

\begin{lemma}[Semantic Weakening] 
  If \(\cwk{\Gamma}{\Delta}\), then 
  \begin{itemize}
    \item For all \(\hasty{\Delta}{p}{a}{A}{q}\),
    \[
      \upg{\dnt{\cwk{\Gamma}{\Delta}}}{p}
      ; \dnt{\hasty{\Delta}{p}{a}{A}{q}}
      = \dnt{\hasty{\Gamma}{p}{a}{A}{q}} 
    \]
    \item For all \(\haslb{\Delta}{t}{\ms{L}}\),
    \[
      \upg{\dnt{\cwk{\Gamma}{\Delta}}}{p}
      ; \dnt{\haslb{\Delta}{t}{\ms{L}}}
      = \dnt{\haslb{\Gamma}{t}{\ms{L}}}  
    \]
  \end{itemize}

  Similarly, if \(\lwk{\ms{L}}{\ms{K}}\) and \(\haslb{\Gamma}{t}{\ms{L}}\), then
  \[
    \dnt{\haslb{\Gamma}{t}{\ms{L}}}
    ; \dnt{\lwk{\ms{L}}{\ms{K}}}
    = \dnt{\haslb{\Gamma}{t}{\ms{K}}}
  \]
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about semantic weakening}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\issubst{\gamma}{\Theta}{\Gamma}}: \mc{C}_1^\varnothing(\dnt{\Theta}, \dnt{\Gamma})} 
    \\
    \dnt{\issubst{\gamma}{\Theta}{\Gamma, \thyp{x}{A}{q}}}
      = \dnt{\csplits{\Theta}{\Theta_\Gamma}{\Theta_x}};\dnt{\issubst{\gamma}{\Theta_\Gamma}{\Gamma}} \otimes \dnt{\hasty{\Theta_x}{1}{a}{A}{q}} \\
    \dnt{\issubst{\cdot}{\cdot}{\cdot}} = \ms{id}
    \\
    \boxed{\dnt{\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}: \mc{C}_0^\varnothing(\dnt{\ms{L}}, \dnt{\ms{K}})} 
  \end{gather*}
  \caption{Semantics for \isotopessa substitutions}
  \Description{Semantics for isotope-SSA substitutions}
  \label{fig:ssa-subst-semantics}
\end{figure}

\TODO{some text about substitution semantics}

\begin{lemma}[Substitution Coherence] \
  \begin{itemize}
    \item Given any two derivations \(D_1: \issubst{\gamma}{\Theta}{\Gamma}\), \(D_2: \issubst{\gamma'}{\Theta}{\Gamma}\) such that \(\forall x \in \Theta, \gamma(x) = \gamma'(x)\), we have \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1: \lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\), \(D_2: \lbsubst{\mc{L}'}{\ms{L}}{\ms{K}}\) such that \(\forall \lbl{\ell} \in \ms{L}, \mc{L}(x) = \mc{L}'(x)\), we have \(\dnt{D_1} = \dnt{D_2}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix? just trivial induction.}

\begin{lemma}[Semantic Substitution Splitting] 
  Given \(\csplits{\Gamma}{\Delta}{\Xi}\) and \(\issubst{\gamma}{\Delta}{\Xi}\),
  if \(\csplits{\Theta}{\Theta_\Delta}{\Theta_\Xi}\) and \(\issubst{\gamma}{\Theta_\Delta}{\Delta}\), \(\issubst{\gamma}{\Theta_\Xi}{\Xi}\), then
  \[
    \dnt{\issubst{\gamma}{\Theta}{\Gamma}};\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
    = \dnt{\csplits{\Theta}{\Theta_\Delta}{\Theta_\Xi}};
      \dnt{\issubst{\gamma}{\Theta_\Delta}{\Delta}}
      \otimes \dnt{\issubst{\gamma}{\Theta_\Xi}{\Xi}}
  \]
\end{lemma}

\begin{theorem}[Semantic Substitution] 
  Given \(\issubst{\gamma}{\Theta}{\Gamma}\),
  \begin{itemize}
    \item For all \(\hasty{\Gamma}{p}{a}{A}{q}\), 
    \[
      \upg{\dnt{\issubst{\gamma}{\Theta}{\Gamma}}}{p}
      ;\dnt{\hasty{\Gamma}{p}{a}{A}{q}} 
      = \dnt{\hasty{\Theta}{p}{[\gamma]a}{A}{q}}
    \]
    \item For all 
      \(\haslb{\Gamma}{t}{\ms{L}}\), 
      \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\), 
      \(\haslb{\Theta}{[\gamma]t}{\ms{K}}\),
    \[
      \upg{\dnt{\issubst{\gamma}{\Theta}{\Gamma}}}{}
      ; \dnt{\haslb{\Gamma}{t}{\ms{L}}}
      = \dnt{\haslb{\Theta}{[\gamma]t}{\ms{K}}} 
      ; \dnt{\lbsubst{\substlbs{\gamma}{\ms{K}}}{\ms{K}}{\ms{L}}}
    \]
    \item For all 
      \(\lhaslb{\ms{W}}{L}{\ms{L}}\), 
      \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\),
      \(\lbsubst{\substlbs{\gamma}{\ms{W'}}}{\ms{W}}{\ms{W'}}\),
      \[
        \dnt{\lbsubst{\substlbs{\gamma}{\ms{W'}}}{\ms{W}}{\ms{W'}}}
        ; \dnt{\lhaslb{\ms{W'}}{[\gamma]L}{\ms{K}}}
        = \dnt{\lhaslb{\ms{W}}{L}{\ms{L}}}
        ; \dnt{\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}}
        + \dnt{\lbsubst{\substlbs{\gamma}{\ms{W'}}}{\ms{W}}{\ms{W'}}}
      \]
  \end{itemize}
  Similarly, given \(\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\),
  \begin{itemize} 
    \item For all \(\haslb{\Gamma}{t}{\ms{L}}\), we have
    \[
      \dnt{\haslb{\Gamma}{t}{\ms{L}}};\dnt{\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}
      = \dnt{\haslb{\Gamma}{[\mc{L}]t}{\ms{K}}}
    \]
    \item For all \(\lhaslb{\ms{W}}{L}{\ms{L}}\), we have
    \[
      \dnt{\lhaslb{\ms{W}}{L}{\ms{L}}};\dnt{\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}
      = \dnt{\lhaslb{\ms{W}}{[\mc{L}]L}{\ms{L}}}
    \]
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}
\TODO{float proof to appendix}

\TODO{some text about semantic substitution}

\begin{figure}
  \begin{align*}
    \dnt{H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}}
      &= \dnt{H} \times \mc{C}_p^q(\dnt{\Gamma}, \dnt{A}) 
      \\
    \dnt{H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}}
      &= \dnt{H} \times \mc{C}_0(\dnt{\Gamma}, \dnt{\ms{L}}) 
      \\
    \dnt{H, \cfghole{\lhole{W}}{\ms{L}}{\ms{K}}}
      &= \dnt{H} \times \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}} + \dnt{\ms{L}}) 
      \\
    \dnt{\cdot} 
      &= \mb{1}
  \end{align*}
  \caption{Semantics for \isotopessa holes}
  \Description{Semantics for isotope-SSA holes}
  \label{fig:holes-semantics}
\end{figure}

\TODO{some text about semantics of holes}

\begin{figure}
  \begin{gather*}
    \boxed{
      \dnt{\mhasty{H}{\Gamma}{p}{\mhole{a}}{A}{q}}
      : \dnt{H} \to \mc{C}_p^q(\dnt{\Gamma}, \dnt{A})}
      \\
    \sorry
  \end{gather*}
  \caption{Semantics for \isotopessa terms with holes}
  \Description{Semantics for isotope-SSA blocks with holes}
  \label{fig:terms-with-holes-semantics}
\end{figure}

\TODO{fill}

\TODO{some text about semantics of terms with holes}

\begin{figure}
  \begin{gather*}
    \boxed{
      \dnt{\mhaslb{H}{\Gamma}{\mhole{t}}{\ms{L}}}
      : \dnt{H} \to \mc{C}_0^\varnothing(\dnt{\Gamma}, \dnt{\ms{L}})}
      \\
    \sorry
      \\  
    \boxed{
      \dnt{\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}}}
      : \dnt{H} \to \mc{C}_0^\varnothing(\dnt{\ms{L}}, \dnt{\ms{K}} + \dnt{\ms{L}})}
      \\
    \sorry
  \end{gather*}
  \caption{Semantics for \isotopessa blocks with holes}
  \Description{Semantics for isotope-SSA blocks with holes}
  \label{fig:blocks-with-holes-semantics}
\end{figure}

\TODO{fill}

\TODO{some text about semantics of blocks with holes}

\begin{figure}
  \begin{gather*}
    \boxed{
      \dnt{\isrw{\mc{H}}{I}{H}}
      : \dnt{I} \to \dnt{H} 
    }
    \\
    \dnt{\isrw{\mc{H}}{I}{\cdot}}\;i = ()
    \qquad
    \dnt{\isrw{\mc{H}}{I}{H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}}}\;i
    = (\dnt{\isrw{\mc{H}}{I}{H}}\;i, \dnt{\mhasty{I}{\Gamma}{p}{\mc{H}(\lhole{X})}{A}{q}}\;i)
    \\
    \dnt{\isrw{\mc{H}}{I}{H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}}}
    = (\dnt{\isrw{\mc{H}}{I}{H}}\;i, \dnt{\mhaslb{I}{\Gamma}{\mc{H}(\lhole{T})}{\ms{L}}}\;i)
    \\
    \dnt{\isrw{\mc{H}}{I}{H, \cfghole{\lhole{L}}{\ms{L}}{\ms{K}}}}
    = (\dnt{\isrw{\mc{H}}{I}{H}}\;i, \dnt{\mlhaslb{I}{\ms{L}}{\mc{H}(\lhole{W})}{\ms{K}}}\;i)
  \end{gather*}
  \caption{Semantics for \isotopessa rewrites}
  \Description{Semantics for isotope-SSA rewrites}
  \label{fig:rewrite-semantics}
\end{figure}

\TODO{fill}

\TODO{some text about semantics of rewrites}

\begin{lemma}[Rewriting Coherence] \
  \begin{itemize}
    \item Given any two derivations \(D_1: \mhasty{H}{\Gamma}{p}{a}{A}{q}\), \(D_2: \mhasty{\Gamma}{p}{H}{a}{A}{r}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \mhaslb{H}{\Gamma}{t}{\ms{L}}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \isrw{\mc{H}}{I}{H}\), \(\dnt{D_1} = \dnt{D_2}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix? just trivial induction}

\begin{theorem}[Semantic Rewriting]
  Given \(\isrw{\mc{H}}{I}{H}\), we have that
  \begin{itemize}
    \item For all \(\mhasty{H}{\Gamma}{p}{a}{A}{q}\), \(m \in \dnt{I}\), we have
    \[
      \dnt{\mhasty{I}{\Gamma}{p}{[\mc{H}]a}{A}{q}}(m)
      = \dnt{\mhasty{H}{\Gamma}{p}{a}{A}{q}}(\dnt{\isrw{\mc{H}}{I}{H}}(m))
    \]
    \item For all \(\mhaslb{H}{\Gamma}{t}{\ms{L}}\), \(m \in \dnt{I}\), we have
    \[
      \dnt{\mhaslb{I}{\Gamma}{[\mc{H}]t}{\ms{L}}}(m)
      = \dnt{\mhaslb{H}{\Gamma}{t}{\ms{L}}}(\dnt{\isrw{\mc{H}}{I}{H}}(m))
    \]
  \end{itemize}

  Furthermore, we have that
  \[
    \dnt{\mhasty{\cdot}{\Gamma}{p}{a}{A}{q}}() = \dnt{\hasty{\Gamma}{p}{a}{A}{q}}
    \qquad
    \dnt{\mhaslb{\cdot}{\Gamma}{t}{\ms{L}}}() = \dnt{\haslb{\Gamma}{t}{\ms{L}}}
  \]
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\subsection{Optimizations}

\TODO{this:}

\TODO{substitution \(\implies\): loop hoisting, global value numbering, some dead code elimination}

\TODO{rewriting \(\implies\) strength reduction, E-graph optimization, see \cite{cranelift}}

\TODO{inlining}

\TODO{loop fusion}

\TODO{unreachable code elimination}

\TODO{more dead code elimination}

\section{Concrete Models}

In this section, we will build on the bare-bones models given in Section \ref{sec:semantics} to develop more sophisticated models capable of underpinning \isotopessa dialects supporting features such as weak memory and separation logic.

\subsection{Trace Models}

\TODO{fix this text}

We will begin by giving a useful foundation for a wide class of \isotopessa models: the "trace models" over \(\mb{Set}\), which accumulate a (potentially infinite) nondeterministic trace of monoidal "events". These will later come in handy for reasoning about output behaviour and weak memory.

We begin with some definitions:
\begin{definition}[Stream Action]
  A \textbf{stream action} of a monoid \(M\) on a set \(I\) equipped with a monoid action \(\cdot: M \times I \to I\) is a function \(\Theta: M^\omega \to I\) is a map from streams of \(M\) to \(I\) satisfying
  \(
    m \cdot \Theta(\ell) = \Theta(m \colon \ell)
  \),
  where \(m \colon \ell\) denotes the stream formed by prefixing \(m\) to the stream \(\ell\).
\end{definition}
Some basic examples include:
\begin{enumerate}
  \item For any monoid \(M\), the unique map \(\Theta: M^\omega \to \mathbf{1}\) forms a stream action on the one element set \(\mathbf{1}\).
  \item Given a monoid \(M\) acting on sets \(I_i\) with action \(\cdot_i\) and stream actions \(\Theta_i: M^\omega \to I_i\), \(\Theta = \langle\Theta_i\rangle_i: M^\omega \to \Pi_iI_i\) is a stream action compatible with the action \(m \cdot l = (m \cdot_i l_i)_i\).
  \item In particular, given monoids \(M_i\) acting on sets \(I_i\) with action \(\cdot_i\) and stream actions \(\Theta_i: M_i^\omega \to I_i\), \(\Theta = \langle \Theta_i \circ \ms{fmap}\;\pi_i\rangle_i: (\Pi_iM_i)^\omega \to \Pi_iI_i\) is a stream action compatible with the action \(m \cdot l = (m_i \cdot_i l_i)_i\).
  \item The concatenation map \(\Theta: (A^*)^\omega \to A^\omega\) is a stream action of \(A^*\), the set of (finite) lists of \(A\), on \(A^{\leq \omega}\), the set of (\textit{potentially} infinite) sequences of \(A\), where \(\ell \cdot s\) prepends the (finite) list \(\ell\) to the (potentially infinite) sequence \(s\).
  \item The sum map \(\Sigma: \nats^\omega \to \nats \cup \{\infty\}\) is a stream action of \(\nats\) on \(\nats \cup \{\infty\}\), where \(\nats\) acts on \(\nats \cup \{\infty\}\) by addition.
\end{enumerate}
We define the \textbf{stream center} of \(M\) with respect to \(I\), denoted \(\mc{SZ}(M, I)\), as the subset of the center of \(M\), \(Z(M)\), consisting of those elements \(m \in Z(M)\) such that for all \(i \in I\), \(m \cdot i = i\). For instance, \(\mc{SZ}(M, \mathbf{1}) = Z(M)\), and \(\mc{SZ}(A^*, A^{\leq \omega}) = Z(A^*) = \{[\,]\}\), while \(\mc{SZ}(\nats, \nats \cup \{\infty\}) = \{0\} \subseteq Z(\nats) = \nats\). Generally, \(\mc{SZ}(M, I)\) always contains the unit of \(M\).

We can now define the \textit{trace monad} of a stream action as follows:
\begin{definition}[Trace Monad]
  Given a stream action \(\Theta\) of \(M\) on \(I\), we can define the \textbf{nondeterministic trace monad} \(\ms{Traces}\;\Theta\;A = \mc{P}^+(A \times M + I)\), with
  \(\eta_A = \lambda a.\iota_0 (a, 1)\)
  and 
  \[\mu_A\;T = \{[\lambda (a, m). m \cdot a, \ms{id}](t) \mid t \in T\}\]
  where the action of \(M\) on traces is given by \(m \cdot \iota_0 (a, m') = \iota_0 (a, mm')\) and \(m \cdot \iota_1 t = \iota_1 (m \cdot t)\). This is an Elgot monad, with iteration operator
  \(f^\dagger(a) = f^\infty(a) \cup \bigcup_{n \in \nats}\{\iota_0 (\iota_0\;b, m) \in f_n(a)\} \cup \{\iota_1 t \in f_n(a)\}\), where
  \[
    f_0 = f, \qquad f_{n + 1} = f \gg [\upg{\iota_0}{}, f_n]
  \]
  \[
    f^\infty(a) = \{\Theta (\lambda n. m_n) \mid a_0 = a \land \forall n, \exists a_{n + 1}. \iota_0 (\iota_1\;a_{n + 1}, m_n) \in f(a_n)\}
  \]
  \TODO{clean this up}
\end{definition}

\TODO{text}

\begin{definition}[Submonad] 
  A \textbf{submonad} \(\mb{S}\) of a monad \(\mb{T}\) on \(\ms{Set}\) is a collection of sets such that, for all \(A\), \(\mb{S}\;A \subseteq \mb{T}\;A\), \(\forall a \in A, \eta\;a \in \mb{S}\;A\), and, for all \(s \in \mb{S}\;A\), \(f: A \to \mb{S}\;B\), \(\mb{bind}\;s\;f \in \mb{S}\;A\). We say that a submonad of \(\mb{T}\) is \textbf{Elgot} if \(\mb{T}\) is Elgot and, for all \(f: A \to \mb{S}(B + A)\), \(f^\dagger: A \to \mb{S}\;B\) where \(f^\dagger\) is computed as in \(\mb{T}\).
\end{definition}
Some important examples of submonads include:
\begin{itemize}
  \item The \textbf{unit submonad} \(\ms{pure}(\mb{T})\) of every monad \(\mb{T}\) with \(\ms{pure}(\mb{T})\;A = \{\eta_A\;a \mid a \in A\}\); similarly, \(\mb{T}\) is itself a submonad of \(\mb{T}\).
  \item Given submonads \(\mb{S}_i\) of \(\mb{T}\), their elementwise unions \(\bigvee_i\mb{S}_i = \lambda A. \bigcup_i \mb{S}_i\;A\) and intersections \(\bigwedge_i\mb{S}_i = \lambda A. \bigcap_i \mb{S}_i\;A\) are submonads, forming a lattice with bottom element \(\ms{pure}(\mb{T})\) and top element \(\mb{T}\)
  \item \todo{commuting absorbtive submonad of trace monad: example of...}
  \item \todo{central submonad. Go cite \cite{carette-central-2022}}
  \item \todo{deterministic, idempotent trace monad: relevant submonad}
  \item \todo{noneffectful trace monad: affine submonad}
  \item \todo{cap and centralize, cap and purify}
\end{itemize}
\TODO{in particular, these induce a substructural effectful category...}

\subsection{Heaps and Separation Logic}

Building on the ideas in \cite{mellies-ftrs}, we will show how a simple separation logic based on \cite{reynolds-separation-2002} slightly adapted to the categorical setting gives us a very rich \isotopessa model supporting a basic notion of refinement types, while at the same time giving us a nontrivial notion of nonlinear types.

We'll start by considering the category \(\ms{HRel}\), which we will take to have morphisms of the form \(A \to \ms{Heap} \to \mc{P}^+(A \times \ms{Heap} \times \ms{Bytes}^* + \ms{Bytes}^{\leq \omega})\), which is the result of applying the state-transformer monad with state \(\ms{Heap}\) to the trace monad with the monoid of lists of bytestrings described in the previous section.

\TODO{say something better than "bytestrings"}

\TODO{what is a \(\ms{Heap}\)}

\TODO{Use name \ms{Traces}}

\TODO{by the above, this is an \isotopessa model w/ nice properties; moving on!}

Given a set \(A\), we can define a predicate \(\varphi\) on \(A\), \(\mb{Heap}\) pairs to have the following type:
\TODO{this}
\TODO{Objects \((A, \varphi)\), \((B, \psi)\)}
\TODO{arrows}
\TODO{note on magic wand}
\TODO{Tensor product and separating conjunction}
\TODO{Coproduct, Elgot structure inherited from base category}
\TODO{sliding w/ properly restricted equality}
\TODO{equality vs \cite{mellies-ftrs}}
\TODO{potential solutions}

\TODO{so, it's a substructural effectful category mmkay}
\TODO{central = no printing}
\TODO{linear objects iff non duplicable}
\TODO{relevant morphisms iff deterministic}
\TODO{affine morphisms always (if no heap effects?)}

\subsection{Weak Memory}

\TODO{text, \cite{sparky}}

\begin{definition}[Pomset] 
  A \textbf{pomset} over a set of actions \(\mc{A}\) with a distinguished null action "\textbf{tick}" \(\delta \in \mc{A}\)
  \TODO{finish, clean}
\end{definition}

\TODO{Form a monoid, so we can define...}

Let \(\ms{Pom}\) denote the monoid of pomsets...

\TODO{stream action... trace monad \(\ms{Traces}\;\ms{Pom}\;\ms{Pom}\)...}

\TODO{The SC Monad, which, via composition w/ the state transformer w/ a buffer as state, lets us}

\TODO{Build The Weak Memory Monad, which is too powerful, so we do...}

\begin{definition}[Monadic Predicate] \
  \TODO{this and naming}
\end{definition}

\TODO{Proper Weak Memory Monad, preserves the Elgot structure (yey)}

\section{Implementation}
 
\TODO{this}

\TODO{remove? time + space...}

\section{Related Work}

\TODO{\cite{leaky-semicolon} for weak memory stuff: future work: add while loops, and also refinement}

\TODO{\cite{schneider-phd}}

\TODO{\cite{chakravarty-functional-ssa-2003}}

\TODO{\cite{barthe-compcert-ssa-2014}}

\TODO{\cite{buchwald-verified-ssa-2016}}

\TODO{\cite{herklotz-gsa-2023}}

\TODO{\cite{pop-ssa-inout-2009}}

\TODO{\cite{garbuzov-structural-cfg-2018}}

\TODO{\cite{hua-explicit-ssa-2010}}

\TODO{\cite{rvsdg}}

\TODO{this}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\clearpage 

\appendix

\section{Appendix}


\end{document}
\endinput
