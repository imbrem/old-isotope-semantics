%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}
\newcommand{\sorry}{\textcolor{red}{\textbf{sorry}}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{TODO \arabic{todos}:} #1}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{\Rightarrow}
\newcommand{\ctt}{\ms{tt}}
\newcommand{\cff}{\ms{ff}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2\;\ms{in}\;#3}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\lbrb}[2]{\brb{\lbl{#1}}{#2}}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\ewhere}[2]{\ms{then}\;#1\;\ms{where}\;#2}
\newcommand{\where}[2]{#1\;\ms{where}\;#2}
\newcommand{\wbranch}[3]{#1(#2) \lto #3}
\newcommand{\lwbranch}[3]{\wbranch{\lbl{#1}}{#2}{#3}}
\newcommand{\bsplice}[3]{#1(#2)\;\{#3\}}
\newcommand{\lbsplice}[3]{\bsplice{\lbl{#1}}{#2}{#3}}
\newcommand{\csplits}[3]{#1 \mapsto #2;#3}
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[2]{#1 \rightsquigarrow #2}
\newcommand{\tlin}[2]{#2 \subseteq \ms{lin}(#1)}
\newcommand{\ltlin}[3]{#3 \subseteq \ms{lin}(#1) \cap #2}
\newcommand{\thyp}[3]{#1: {#2}^{#3}}
\newcommand{\lhyp}[3]{#1[#2](#3)}
\newcommand{\llhyp}[3]{\lhyp{\lbl{#1}}{#2}{#3}}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\taff}{\ms{a}}
\newcommand{\trel}{\ms{r}}
\newcommand{\tint}{\infty}
\newcommand{\hasty}[5]{#1 \vdash_{#2} #3: {#4}^{#5}}
\newcommand{\haslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\lhaslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\issubst}[3]{#1: #2 \mapsto #3}
\newcommand{\lbsubst}[3]{#1: #2 \rightsquigarrow #3}
\newcommand{\exprletsubst}[2]{{#1};{#2}}
\newcommand{\stmtletsubst}[2]{{#1};{#2}}
\newcommand{\mhole}[1]{{#1}^?}
\newcommand{\lhole}[1]{?#1}
\newcommand{\mhasty}[6]{#1;#2 \vdash_{#3} #4: {#5}^{#6}}
\newcommand{\mhaslb}[4]{#1;#2 \vdash #3 \rhd #4}
\newcommand{\mlhaslb}[4]{#1;#2 \vdash #3 \rhd #4}
\newcommand{\tyhole}[5]{#1: #2 \mapsto_{#3} {#4}^{#5}}
\newcommand{\blkhole}[3]{#1: #2 \mapsto #3}
\newcommand{\cfghole}[3]{#1: #2 \mapsto #3}
\newcommand{\substctx}[2]{{#1}^{#2}}
\newcommand{\substlbs}[2]{{#1}^{#2}}
\newcommand{\restrictsubst}[2]{{#1}_{#2}}
\newcommand{\subsubst}[2]{#1 \subseteq #2}
\newcommand{\isrw}[3]{#1: #2 \mapsto #3}
% \newcommand{\strictlbsubst}[3]{#1: #2 \rightsquigarrow_= #3}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}
\newcommand{\upg}[2]{{#1}^{\uparrow #2}}

% Branding
\newcommand{\isotopessa}{\ms{isotope_{SSA}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Effectful Semantics for Substructural SSA}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\begin{abstract}
  Static single-assignment form (SSA) is one of the most widely used
  compiler intermediate representations. In this paper, we build on
  the observation that SSA can be seen as a language of basic blocks
  with arguments (or first-order procedures tail-calling one another)
  to give a type theory for SSA programs. Notably, the type system and
  equational theory of our language is designed to support
  substituting impure terms for variables, which makes it easy to
  validate compiler optimisations such as hoisting assignments out of
  loops.

  We give a categorical axiomatisation of our type theory and show
  that our equational theory is sound with respect to it. Our
  categorical semantics generalises the notions of premonoidal
  category and Freyd category to support substructural features,
  including both support for substructural types, as well as
  F\"{u}hrmann's notion of central, copyable and discardable
  morphisms.

  Finally, we exhibit a number of concrete models of our categorical
  axiomatisation, including in particular a model of TSO-style weak
  memory based on the semantics of \citet{sparky}. This demonstrates
  that our approach is strong enough to connect machine models of
  concurrency to compiler IRs supporting a rich collection of sound
  rewrites.
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011742</concept_id>
  <concept_desc>Theory of computation~Separation logic</concept_desc>
  <concept_significance>300</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[300]{Theory of computation~Separation logic}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle


\section{Introduction}

Static Single Assignment, or SSA, has been a cornerstone of compiler
design ever since its introduction by \cite{ssa-original} in the late
1980s. Older compiler intermediate representations permitted the same
local variable to be assigned multiple times, whereas SSA requires
each variable bindings to be immutable -- they cannot be modified
after initialisation. This makes many dataflow analyses easier to
compute, and (just as in functional languages) makes it much easier to
justify compiler optimisations in terms of equational rewrites.

In fact, the relationship between SSA form and functional programming
has been known for decades: \citet{kelsey-ssa-cps} showed that SSA can
be seen as a subset of continuation-passing style, and
\citet{appel-ssa} built on this to observe that every SSA program can
be viewed as a collection of first-order functions which tail-call one
another. This makes the equivalence of the functional view to the
traditional $\phi$-node presentation very easy to see. In the
functional style, each tail call lists its arguments. In contrast, a
$\phi$-node collects together the arguments from every callsite, which
lets the tail-calls/jumps to omit their arguments. Thus, the main
difference between SSA and a functional program is where in the
program text the arguments to a tail call are listed.

\TODO{Example here?}

This ``basic blocks with arguments'' presentation of SSA has become
very popular in industry, with compiler backends such as
Cranelift~\cite{cranelift}, MLIR~\cite{mlir}, and SIL~\cite{SIL} all
using this representation. This tight connection might suggest that
the semantics of SSA representations is trivial: we can just interpret
an SSA program as a corresponding functional program, and then rewrite
the SSA programs using the equational theory of functional programs.

While this is a perfectly sound thing to do, it is not strong enough
to write a good compiler. Compiler IRs like SSA are fundamentally
about effectful programs, and the equational theory of effectful
functional programs is very weak. Instead of a full substitution rule,
the equational theory of impure functional languages only justifies
substituting values for variables (the $\beta$-value rule). This weak
substitution rule suffices to validate some basic compiler
optimisations such as constant propagation and copy propagation, but
is not strong enough to justify many other essential compiler
optimisations. For example, hoisting a store out of a loop or
conditional involves moving an effectful term (an assignment) out of
its original position in the program. As another example, dead store
elimination removes an effectful term from the program altogether. \todo{Another example?}

These examples illustrate that many optimisations require taking
\emph{effectful} terms and moving them around and substituting them
for variables.







% 
% , on which projects such as the LLVM compiler infrastructure, GCC's GIMPLE intermediate representation, Cranelift, and MLIR are based. One of the core advantages of putting programs in SSA form is the ability to reason about programs in a more equational manner: since variables always have exactly one definition, we can justify complex optimizations like global value numbering (which would otherwise need to take into account complex flow-sensitive definitions) and more easily implement various analyses. 
% 
\TODO{text...}

\paragraph{Contributions}

\begin{itemize}
\item We have a syntax and type system for SSA-style programs. We include support for substructural types, and our type-theoretic syntax makes formulating inlining and rewriting easier than in the traditional CFG-based formulations. 
\item We show that our language has a compositional intepretation in any effectful category with an Elgot structure. We use this structure to give generic proofs of the expected substitution properties as well as prove the soundness of an equational theory for the language.
\item Our generic equational theory justifies a variety of powerful optimisation techniques, including E-graph rewriting, inlining, loop fusion, hoisting, and strength reduction. 
\item We show how Elgot monads give rise to models of our language. We use this to derive semantics from a general trace monad, and show that various monad transformers such as state transformers preserve the needed Elgot structure. 
\item We use these tools to demonstrate the existence of a variety of concrete models satisfying these categorical axioms. Starting first from simple languges such as state plus printing, we also show how more challenging semantics such as the TSO semantics for weak memory also fit into our framework. This thus gives rise to an SSA-based IR with support for weak memory operations, which is fully semantically-justified.
\item \TODO{We also have a small implementation, which \ldots}
\item Our weak memory semantics and our results about Elgot monads are formalised in the Lean theorem prover. \TODO{Other stuff}
\end{itemize}

\section{Background}

In a standard SSA-based compiler, to represent a function, we begin by decomposing it into basic blocks of the following form:
\begin{lstlisting}
'label:
  var = instruction
  ...
  var = instruction
  terminator
\end{lstlisting}
A program written in this manner being in ``SSA form'' simply means that every variable name is defined exactly once. For example,
\begin{lstlisting}
'entry:
  x = 7
  x = add x 2
  ret x
\end{lstlisting}
is not in SSA form, but can easily be converted into SSA form by rewriting it as
\begin{lstlisting}
'entry:
  x0 = 7
  x1 = add x0 2
  ret x1
\end{lstlisting}
Unfortunately, things get a little more tricky when we try to define variables in loops or branches. For example, consider the following code:
\begin{lstlisting}
'entry:
  br arg0 'left `right
'left:
  x = 7
  jmp 'exit
'right:
  x = 3
  jmp 'exit
'exit:
  ret x
\end{lstlisting}
There are two competing definitions of \(x\) in the left and right blocks, and itâ€™s unclear how to disambiguate between them. The usual solution is to introduce a \(\phi\)-node. In particular, we can write:
\begin{lstlisting}
'entry:
  br arg0 'left `right
'left:
  x0 = 7
  jmp 'exit
'right:
  x1 = 3
  jmp 'exit
'exit:
  x2 = phi 'left x0 'right x1
  ret x2
\end{lstlisting}
\TODO{make above into graphs?}
\TODO{segue}
The semantics of SSA, however, can be quite complex to reason about, especially when considering the somewhat unintuitive scoping rules of variables and \(\phi\)-function arguments.

\TODO{basic-blocks with arguments}

\TODO{dominance frontiers}

\TODO{inductive presentation}

\TODO{what we're doing}

\section{SSA Syntax}

\TODO{text}

\begin{figure}
  \begin{center}
    \begin{grammar}
      <\(A, B, C\)> ::= 
      \(X\)
      \;|\; \(\mathbf{1}\)
      \;|\; \(\mathbf{2}\)
      \;|\; \(A \otimes B\)

      <\(a, b, c, e\)> ::= \(x\) 
      \;|\; \(f\;a\)
      \;|\; \((a, b)\) 
      \;|\; \(()\) 
      \;|\; \(\ctt\) 
      \;|\; \(\cff\)
      \;|\; \(\letexpr{x}{a}{e}\)
      \;|\; \(\letexpr{(x, y)}{a}{e}\)
      \;|\; \(\lbsplice{\ell}{x: A}{t}\)
      
      <\(s, t\)> ::= \(\lbrb{\ell}{a}\) 
      \;|\; \(\ite{e}{s}{t}\)
      \;|\; \(\letstmt{x}{a}{t}\)
      \;|\; \(\letstmt{(x, y)}{a}{t}\)
      \;|\; \(\ewhere{t}{L}\)

      <\(L\)> ::= \(\cdot\) \;|\; \(\lwbranch{\ell}{x: A}{t}, L\)

      <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, \thyp{x}{A}{q}\)

      <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \lbl{\ell}[\Gamma](x: A)\)

      <\(p\)> ::= 0 \;|\; 1

      <\(q\)> ::= \(\varnothing\) 
      \;|\; \(\{\taff\}\) 
      \;|\; \(\{\trel\}\) 
      \;|\; \(\{\taff, \trel\}\)
    \end{grammar}
  \end{center}
  \caption{Grammar for \isotopessa, parametrized over a set of instructions \(f \in \mc{I}\)}
  \Description{Grammar for isotope-SSA}
  \label{fig:ssa-grammar}
\end{figure}

\TODO{late \ms{where}-binding, and other sugar (?)}

\TODO{top-level functions}

\TODO{table of typing judgements}

\TODO{contexts, label-contexts}

\begin{figure}
  \begin{center}        
    \begingroup
    \renewcommand{\arraystretch}{1.5}
    \setlength{\tabcolsep}{2em}
    \begin{tabular}{rl}
        \multicolumn{1}{c}{Judgment} & \multicolumn{1}{c}{Meaning} \\ \hline
        \(\hasty{\Gamma}{p}{x}{A}{q}\) &
        \(a\) is a term of type \(A\) in context \(\Gamma\) with purity \(p\) and quantity \(q\) \\
        \(\haslb{\Gamma}{t}{\ms{L}}\) &
        \(t\) is a block targeting label-set \(\ms{L}\) in context \(\Gamma\) \\
        \(\lhaslb{\ms{L}}{L}{\ms{K}}\) &
        The labels \(L\) send label-set \(\ms{L}\) to label-set \(\ms{K}\) \\
        \(\csplits{\Gamma}{\Delta}{\Xi}\) &
        The context \(\Gamma\) splits into \(\Delta\) and \(\Xi\) \\
        \(\lwk{\ms{L}}{\ms{K}}\) &
        The label-set \(\ms{L}\) weakens to the label-set \(\ms{K}\) \\
        % \(\tlin{A}{q}\) &
        % The type \(A\) can be used with linearity \(q\) \\
        % \(\ltlin{A}{r}{q}\) &
        % The type \(A\) can be used with linearity \(q \subseteq r\)
        % (i.e. \(\tlin{A}{q} \land q \subseteq r\)) \\
        % \(\tlin{\Gamma}{q}\) &
        % The context \(\Gamma\) has linearity \(q\) \\
        \(\cwk{\Gamma}{\Delta}\) &
        \(\Gamma\) is a weakening of \(\Delta\) 
        (i.e. \(\csplits{\Gamma}{\Delta}{\cdot}\))
    \end{tabular}
    \endgroup
  \end{center}
  \caption{Typing judgements for \isotopessa}
  \Description{Typing judgements for isotope-SSA}
  \label{fig:ssa-judgements}
\end{figure}

\TODO{some text about each typing judgement}

\begin{figure}
  \begin{gather*}    
    % \prftree[r]{\rle{base-lin}}{q \subseteq \ms{lin}(X)}{\tlin{X}{q}} \qquad
    \prftree[r]{\rle{unit-lin}}{}{\tlin{\mathbf{1}}{q}} 
    \qquad
    \prftree[r]{\rle{bool-lin}}{}{\tlin{\mathbf{2}}{q}} 
    \qquad
    \prftree[r]{\rle{pair-lin}}{\tlin{A}{q}}{\tlin{B}{q}}{\tlin{A \otimes B}{q}} \\
    \prftree[r]{\rle{nil-lin}}{\tlin{\cdot}{q}} \qquad
    \prftree[r]{\rle{cons-lin}}{\ltlin{A}{r}{q}}{\tlin{\Gamma}{q}}
      {\tlin{\Gamma, \thyp{x}{A}{r}}{q}} \\
    \prftree[r]{\rle{split-nil}}{\csplits{\cdot}{\cdot}{\cdot}} \qquad
    \prftree[r]{\rle{split-left}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {r \subseteq q}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta, \thyp{x}{A}{r}}{\Xi}} \qquad
    \prftree[r]{\rle{split-right}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {r \subseteq q}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta}{\Xi, \thyp{x}{A}{r}}} \\
    \prftree[r]{\rle{split-dup}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\ltlin{A}{q}{\trel}}
      {r, s \subseteq q}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta, \thyp{x}{A}{r}}{\Xi, \thyp{x}{A}{s}}}
      \qquad
    \prftree[r]{\rle{split-drop}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\ltlin{A}{q}{\taff}}
      {\csplits{\Gamma, \thyp{x}{A}{q}}{\Delta}{\Xi}}
      \\
    \prftree[r]{\rle{join-nil}}{\lwk{\cdot}{\cdot}} \qquad
    \prftree[r]{\rle{join-cons}}
      {\lwk{\ms{L}}{\ms{K}}}
      {\cwk{\Gamma}{\Delta}}
      {\lwk{\ms{L}, \llhyp{\ell}{\Gamma}{A}}{\ms{K}, \llhyp{\ell}{\Delta}{A}}} 
      \qquad
    \prftree[r]{\rle{join-zero}}
      {\lwk{\ms{L}}{\ms{K}}}
      {\lwk{\ms{L}}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}} 
  \end{gather*}
  \caption{Structural rules for \isotopessa}
  \Description{Structural rules for isotope-SSA}
  \label{fig:ssa-structural}
\end{figure}

\TODO{some text about each structural rule}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma}{\thyp{x}{A}{q}}}
      {\hasty{\Gamma}{p}{x}{A}{q}} \qquad
    \prftree[r]{\rle{app}}
      {f \in \mc{I}_p^q(A, B)}
      {\hasty{\Gamma}{1}{a}{A}{q}}
      {\hasty{\Gamma}{p}{f\;a}{B}{q}} \qquad
    \prftree[r]{\rle{pair}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta}{1}{a}{A}{q}}
      {\hasty{\Xi}{1}{b}{B}{q}}
      {\hasty{\Gamma}{p}{(a, b)}{A \otimes B}{q}} \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma}{\cdot}}
      {\hasty{\Gamma}{p}{()}{\mb{1}}{q}} \qquad
    \prftree[r]{\rle{true}}
      {\cwk{\Gamma}{\cdot}}
      {\hasty{\Gamma}{p}{\ctt}{\mb{2}}{q}} \qquad
    \prftree[r]{\rle{false}}
      {\cwk{\Gamma}{\cdot}}
      {\hasty{\Gamma}{p}{\cff}{\mb{2}}{q}} \\
    \prftree[r]{\rle{let}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta, \thyp{x}{A}{}}{p}{e}{B}{q}}
      {\hasty{\Xi}{1}{a}{A}{q}}
      {\hasty{\Gamma}{p}{\letexpr{x}{a}{e}}{B}{q}} \qquad
    \prftree[r]{\rle{blk}}
      {\haslb{\Gamma}{t}{\llhyp{\ell}{\cdot}{A}}}
      {\hasty{\Gamma}{0}{\lbsplice{\ell}{A}{t}}{A}{\varnothing}} \\
    \prftree[r]{\rle{let2}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{p}{e}{C}{q}}
      {\hasty{\Xi}{1}{a}{A \otimes B}{q}}
      {\hasty{\Gamma}{p}{\letexpr{(x, y)}{a}{e}}{C}{q}}
  \end{gather*}
  \caption{Typing rules for \isotopessa terms}
  \Description{Typing rules for isotope-SSA terms}
  \label{fig:ssa-term-typing}
\end{figure}

\TODO{some text about each typing rule}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{br}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\lwk{\llhyp{\ell}{\Delta}{A}}{\ms{L}}}
      {\hasty{\Xi}{1}{a}{A}{\tint}}
      {\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} \qquad
    \prftree[r]{\rle{ite}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\hasty{\Delta}{1}{e}{\mb{2}}{\tint}}
      {\haslb{\Xi}{s}{\ms{L}}}
      {\haslb{\Xi}{t}{\ms{L}}}
      {\haslb{\Gamma}{\ite{e}{s}{t}}{\ms{L}}} \\
    \prftree[r]{\rle{let-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\haslb{\Delta, \thyp{x}{A}{}}{t}{\ms{L}}}
      {\hasty{\Xi}{0}{a}{A}{q}}
      {\haslb{\Gamma}{\letstmt{x}{a}{t}}{\ms{L}}} \\
    \prftree[r]{\rle{let2-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\haslb{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{t}{\ms{L}}}
      {\hasty{\Xi}{0}{a}{A \otimes B}{q}}
      {\haslb{\Gamma}{\letstmt{(x, y)}{a}{t}}{\ms{L}}} \\
    \prftree[r]{\rle{where}}
      {\haslb{\Gamma}{t}{\ms{L}}}
      {\lhaslb{\ms{L}}{L}{\ms{K}}}
      {\haslb{\Gamma}{\ewhere{t}{L}}{\ms{K}}} \qquad
    \prftree[r]{\rle{nil-br}}
      {\lhaslb{\ms{L}}{\cdot}{\ms{L}}} \qquad
    \prftree[r]{\rle{cons-br}}
      {\lhaslb{\ms{L}}{L}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      {\haslb{\Gamma, \thyp{x}{A}{}}{t}{\ms{L}}}
      {\lhaslb{\ms{L}}{L, \lwbranch{\ell}{x: A}{t}}{\ms{K}}}
  \end{gather*}
  \caption{Typing rules for \isotopessa blocks}
  \Description{Typing rules for isotope-SSA blocks}
  \label{fig:ssa-block-typing}
\end{figure}

\TODO{some text about each block typing rule}

\subsection{Syntactic Metatheory}

\begin{theorem}[Weakening] \
  \begin{itemize}
    \item If \(\cwk{\Gamma}{\Delta}\) and \(q \subseteq r\), \(\hasty{\Delta}{p}{a}{A}{r}\), then \(\hasty{\Gamma}{p}{a}{A}{q}\)
    \item If \(\cwk{\Gamma}{\Delta}\), \(\haslb{\Delta}{t}{\ms{L}}\), then \(\haslb{\Gamma}{t}{\ms{L}}\)
    \item If \(\lwk{\ms{L}}{\ms{K}}\), \(\haslb{\Gamma}{t}{\ms{L}}\) then \(\haslb{\Gamma}{t}{\ms{K}}\)
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\begin{figure}
  \begin{center}        
    \begingroup
    \renewcommand{\arraystretch}{1.5}
    \setlength{\tabcolsep}{2em}
    \begin{tabular}{rl}
        \multicolumn{1}{c}{Judgment} & \multicolumn{1}{c}{Meaning} \\ \hline
        \(\issubst{\gamma}{\Theta}{\Gamma}\) &
        ... \\
        \(\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\) &
        ... \\
        \(\mhasty{H}{\Gamma}{p}{\mhole{a}}{A}{q}\) &
        ... \\
        \(\mhaslb{H}{\Gamma}{\mhole{t}}{\ms{L}}\) &
        ... \\
        \(\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}}\) &
        ... \\
        \(\isrw{\mc{H}}{I}{H}\) &
        ... \\
    \end{tabular}
    \endgroup
  \end{center}
  \caption{Metatheoretic typing judgements for \isotopessa}
  \Description{Metatheoretic typing judgements for isotope-SSA}
  \label{fig:ssa-meta-judgements}
\end{figure}

\TODO{some text about each metatheoretic judgement}

\begin{figure}
  \begin{gather*}
    \boxed{\gamma: \ms{Var} \to \ms{Expr}}
    \\
    \prftree[r]{\rle{subst-nil}}
      {\issubst{\gamma}{\cdot}{\cdot}}
      \qquad
    \prftree[r]{\rle{subst-cons}}
      {\issubst{\gamma}{\Theta_\Gamma}{\Gamma}}
      {\hasty{\Theta_x}{1}{\gamma(x)}{A}{q}}
      {\tlin{\Theta_x}{q}}
      {\csplits{\Theta}{\Theta_\Gamma}{\Theta_x}}
      {\issubst{\gamma}{\Theta}{\Gamma, \thyp{x}{A}{q}}}
    \\
    \boxed{\mc{L}: \ms{Label} \to \ms{Expr} \to \ms{Block} \text{ s.t. for fresh } x, [a/x]\mc{L}(\lbl{\ell}, x) = \mc{L}(\lbl{\ell}, a)}
    \\
    \prftree[r]{\rle{lb-subst-nil}}
    {\lbsubst{\mc{L}}{\cdot}{\ms{K}}}
      \qquad
    \prftree[r]{\rle{lb-subst-cons}}
      {\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}
      {\haslb{\Gamma, \thyp{x}{A}{}}{\mc{L}(\lbl{\ell}, x)}{\ms{K}}}
      {\lbsubst{\mc{L}}{\ms{L}, \llhyp{\ell}{\Gamma}{A}}{\ms{K}}}
  \end{gather*}
  \caption{
    Typing rules for \isotopessa substitutions. 
    We generally assume that for all but finitely many variables \(x\) and labels \(\lbl{\ell}\), \(\gamma(x) = x\) and \(\mc{L}(\lbl{\ell}, x) = \lbrb{\ell}{x}\).
  }
  \Description{Typing rules for isotope-SSA substitutions}
  \label{fig:ssa-subst-typing}
\end{figure}

\TODO{some text about substitution}

\begin{figure}
  \begin{gather*}
    % \restrictsubst{\gamma}{\Gamma}(x) 
    %   =
    %   (\ms{if}\; x \in \Gamma
    %   \;\ms{then}\;\gamma(x)
    %   \;\ms{else}\;x)
    % \\
    \stmtletsubst{\substctx{\gamma}{\cdot}}{t} = t
    \qquad
    \stmtletsubst{\substctx{\gamma}{\Gamma, x: A^q}}{t} 
      = \letstmt{x}{\gamma(x)}{\stmtletsubst{\substctx{\gamma}{\Gamma}}{t}}
    \qquad
    \exprletsubst{\cdot}{e} = e
    \qquad
    \exprletsubst{\substctx{\gamma}{\Gamma, x: A^q}}{e} 
      = \letstmt{x}{\gamma(x)}{\substctx{\gamma}{\Gamma}}
    \\
    \substlbs{\gamma}{\cdot}(\lbl{\ell}, x) = \lbrb{\ell}{x}
    \qquad
    \substlbs{\gamma}{\ms{L}, \llhyp{\ell}{\Gamma}{A}}(\lbl{k}, x)
      = 
      (\ms{if}\; \lbl{k} = \lbl{\ell} 
      \;\ms{then}\;\stmtletsubst{\substctx{\gamma}{\Gamma}}{\lbrb{\ell}{x}}
      \;\ms{else}\;\substlbs{\gamma}{\ms{L}}(\lbl{\ell}, x))
    \\
    [\mc{L}](\lbrb{\ell}{a}) = \mc{L}(\lbl{\ell}, a)
    \qquad
    [\mc{L}]\ite{e}{s}{t} = \ite{e}{[\mc{L}]s}{[\mc{L}]t}
    \\
    [\mc{L}](\letstmt{x}{a}{t}) = (\letstmt{x}{a}{[\mc{L}]t})
    \qquad
    [\mc{L}](\letstmt{(x, y)}{a}{t}) = (\letstmt{(x, y)}{a}{[\mc{L}]t})
    \\
    [\mc{L}]\ewhere{t}{L} = \ewhere{[\mc{L}]t}{[\mc{L}]L}
    \\
    [\mc{L}]\cdot = \cdot
    \qquad
    [\mc{L}](\lwbranch{\ell}{x: A}{t})
    = (\lwbranch{\ell}{x: A}{[\mc{L}]t})
  \end{gather*}
  \caption{Operations on \isotopessa substitutions.}
  \Description{Operations on isotope-SSA substitutions}
  \label{fig:ssa-subst-ops}
\end{figure}

\TODO{some text about substitution operations}

\begin{lemma}[Substitution Splitting] 
  If \(\csplits{\Gamma}{\Delta}{\Xi}\) and \(\issubst{\gamma}{\Theta}{\Gamma}\), then there exist \(\Theta_\Delta\), \(\Theta_\Xi\) such that:
  \begin{itemize}
    \item \(\csplits{\Theta}{\Theta_\Delta}{\Theta_\Xi}\)
    \item \(\issubst{\gamma}{\Theta_\Delta}{\Delta}\)
    \item \(\issubst{\gamma}{\Theta_\Xi}{\Xi}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix?}

\TODO{some text about substitution weakening}

\begin{theorem}[Substitution] 
  Given \(\issubst{\gamma}{\Theta}{\Gamma}\),
  \begin{itemize}
    \item If \(\hasty{\Gamma}{p}{a}{A}{q}\), then \(\hasty{\Theta}{p}{[\gamma]a}{A}{q}\)
    \item If \(\haslb{\Gamma}{t}{\ms{L}}\), then there exists \(\ms{K}\) such that \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\) and \(\haslb{\Theta}{[\gamma]t}{\ms{K}}\)
    \item If \(\lhaslb{\ms{W}}{L}{\ms{L}}\), then there exists \(\ms{K}, \ms{W}'\) such that 
    \begin{itemize}
      \item \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\) 
      \item \(\lbsubst{\substlbs{\gamma}{\ms{W}'}}{\ms{W}}{\ms{W}'}\) 
      \item \(\lhaslb{\ms{W}'}{[\gamma]L}{\ms{K}}\)
    \end{itemize}
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about substitution}

\begin{theorem}[Label Substitution] 
  Given \(\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\), 
  \begin{itemize}
    \item For all \(\haslb{\Gamma}{t}{\ms{L}}\), \(\haslb{\Gamma}{[\mc{L}]t}{\ms{K}}\)
    \item For all \(\lhaslb{\ms{W}}{L}{\ms{L}}\), \(\lhaslb{\ms{W}}{[\mc{L}]L}{\ms{K}}\)
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about label substitution}

\begin{figure}
  \begin{grammar}
    <\(\mhole{a}, \mhole{b}, \mhole{c}, \mhole{e}\)> ::= \(\lhole{X}\)
    \;|\; \(x\) 
    \;|\; \(f\;\mhole{a}\)
    \;|\; \((\mhole{a}, \mhole{b})\) 
    \;|\; \(()\) 
    \;|\; \(\ctt\) 
    \;|\; \(\cff\)
    \;|\; \(\letexpr{x}{\mhole{a}}{\mhole{e}}\)
    \;|\; \(\letexpr{(x, y)}{\mhole{a}}{\mhole{e}}\)
    \alt \(\lbsplice{\ell}{x: A}{\mhole{t}}\)

    <\(\mhole{s}, \mhole{t}\)> ::= \(\lhole{T}\) 
    \;|\; \(\lbrb{\ell}{\mhole{a}}\) 
    \;|\; \(\ite{\mhole{e}}{\mhole{s}}{\mhole{t}}\)
    \;|\; \(\letstmt{x}{\mhole{a}}{\mhole{t}}\)
    \;|\; \(\letstmt{(x, y)}{\mhole{a}}{\mhole{t}}\)
    \;|\; \(\ewhere{\mhole{t}}{\mhole{L}}\)

    <\(\mhole{L}\)> ::= \(\lhole{W}\) \;|\; \(\cdot\) \;|\; \(\lwbranch{\ell}{x: A}{\mhole{t}}, \mhole{L}\)

    <\(H\)> ::= \(\cdot\) 
    \;|\; \(H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}\)
    \;|\; \(H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}\)
    \;|\; \(H, \cfghole{\lhole{W}}{\ms{L}}{\ms{K}}\)
  \end{grammar}
  \caption{Grammar for \isotopessa terms and blocks with holes}
  \Description{Grammar for isotope-SSA blocks with holes}
  \label{fig:blocks-with-holes-grammar}
\end{figure}

\TODO{some text about terms with holes}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{hole-tm}}
      {\tyhole{\lhole{X}}{\Delta}{p}{A}{q}}
      {\cwk{\Gamma}{\Delta}}
      {\mhasty{H}{\Gamma}{p}{\lhole{X}}{A}{q}} \qquad
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma}{\thyp{x}{A}{q}}}
      {\mhasty{H}{\Gamma}{p}{x}{A}{q}} \qquad
    \prftree[r]{\rle{app}}
      {f \in \mc{I}_p^q(A, B)}
      {\mhasty{H}{\Gamma}{1}{\mhole{a}}{A}{q}}
      {\mhasty{H}{\Gamma}{p}{f\;\mhole{a}}{B}{q}} \\
    \prftree[r]{\rle{pair}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta}{1}{\mhole{a}}{A}{q}}
      {\mhasty{H}{\Xi}{1}{\mhole{b}}{B}{q}}
      {\mhasty{H}{\Gamma}{p}{(\mhole{a}, \mhole{b})}{A \otimes B}{q}} \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma}{\cdot}}
      {\mhasty{H}{\Gamma}{p}{()}{\mb{1}}{q}} \qquad
    \prftree[r]{\rle{true}}
      {\cwk{\Gamma}{\cdot}}
      {\mhasty{H}{\Gamma}{p}{\ctt}{\mb{2}}{q}} \qquad
    \prftree[r]{\rle{false}}
      {\cwk{\Gamma}{\cdot}}
      {\mhasty{H}{\Gamma}{p}{\cff}{\mb{2}}{q}} \\
    \prftree[r]{\rle{let}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta, \thyp{x}{A}{}}{p}{\mhole{e}}{B}{q}}
      {\mhasty{H}{\Xi}{1}{\mhole{a}}{A}{q}}
      {\mhasty{H}{\Gamma}{p}{\letexpr{x}{\mhole{a}}{\mhole{e}}}{B}{q}} \qquad
    \prftree[r]{\rle{blk}}
      {\mhaslb{H}{\Gamma}{\mhole{t}}{\llhyp{\ell}{\cdot}{A}}}
      {\mhasty{H}{\Gamma}{0}{\lbsplice{\ell}{A}{\mhole{t}}}{A}{\varnothing}} \\
    \prftree[r]{\rle{let2}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{p}{\mhole{e}}{C}{q}}
      {\mhasty{H}{\Xi}{1}{\mhole{a}}{A \otimes B}{q}}
      {\mhasty{H}{\Gamma}{p}{\letexpr{(x, y)}{\mhole{a}}{\mhole{e}}}{C}{q}}
  \end{gather*}
  \caption{Typing rules for \isotopessa terms with holes}
  \Description{Typing rules for isotope-SSA terms with holes}
  \label{fig:terms-with-holes-typing}
\end{figure}

\TODO{some text about term with hole typing rules}

\begin{figure}
  \begin{gather*}    
    \prftree[r]{\rle{hole-blk}}
      {\blkhole{\lhole{T}}{\Delta}{\ms{L}} \in H}
      {\cwk{\Gamma}{\Delta}}
      {\mhaslb{H}{\Gamma}{\lhole{T}}{\ms{L}}} 
      \qquad
    \prftree[r]{\rle{br}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\lwk{\llhyp{\ell}{\Delta}{A}}{\ms{L}}}
      {\mhasty{H}{\Xi}{1}{\mhole{a}}{A}{\tint}}
      {\mhaslb{H}{\Gamma}{\lbrb{\ell}{\mhole{a}}}{\ms{L}}} 
      \\
    \prftree[r]{\rle{ite}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhasty{H}{\Delta}{1}{\mhole{e}}{\mb{2}}{\tint}}
      {\mhaslb{H}{\Xi}{\mhole{s}}{\ms{L}}}
      {\mhaslb{H}{\Xi}{\mhole{t}}{\ms{L}}}
      {\mhaslb{H}{\Gamma}{\ite{\mhole{e}}{\mhole{s}}{\mhole{t}}}{\ms{L}}} \\
    \prftree[r]{\rle{let-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhaslb{H}{\Delta, \thyp{x}{A}{}}{\mhole{t}}{\ms{L}}}
      {\mhasty{H}{\Xi}{0}{\mhole{a}}{A}{q}}
      {\mhaslb{H}{\Gamma}{\letstmt{x}{\mhole{a}}{\mhole{t}}}{\ms{L}}} \\
    \prftree[r]{\rle{let2-blk}}
      {\csplits{\Gamma}{\Delta}{\Xi}}
      {\mhaslb{H}{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{\mhole{t}}{\ms{L}}}
      {\mhasty{H}{\Xi}{0}{\mhole{a}}{A \otimes B}{q}}
      {\mhaslb{H}{\Gamma}{\letstmt{(x, y)}{\mhole{a}}{\mhole{t}}}{\ms{L}}} \\
    \prftree[r]{\rle{where}}
      {\mhaslb{H}{\Gamma}{\mhole{t}}{\ms{L}}}
      {\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}}}
      {\mhaslb{H}{\Gamma}{\ewhere{\mhole{t}}{\mhole{L}}}{\ms{K}}} 
      \qquad
    \prftree[r]{\rle{hole-cfg}}
      {\cfghole{\lhole{W}}{\ms{L}}{\ms{K}} \in H}
      {\lwk{\ms{M}}{\ms{K}}}
      {\mlhaslb{\ms{L}}{H}{\lhole{W}}{\ms{K}}}
      \\
    \prftree[r]{\rle{nil-br}}
      {\mlhaslb{H}{\ms{L}}{\cdot}{\ms{L}}} \qquad
    \prftree[r]{\rle{cons-br}}
      {\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      {\mhaslb{H}{\Gamma, \thyp{x}{A}{}}{\mhole{t}}{\ms{L}}}
      {\mlhaslb{H}{\ms{L}}{\mhole{L}, \lwbranch{\ell}{x: A}{\mhole{t}}}{\ms{K}}}
  \end{gather*}
  \caption{Typing rules for \isotopessa blocks with holes}
  \Description{Typing rules for isotope-SSA blocks with holes}
  \label{fig:blocks-with-holes-typing}
\end{figure}

\TODO{some text about block with hole typing rules}

\begin{figure}
  \begin{gather*}
    \boxed{H: \ms{Hole} \to \ms{MExpr} \sqcup \ms{MBlock} \sqcup \ms{MCfg}}
    \\
    \prftree[r]{\rle{rw-nil}}
      {\isrw{\mc{H}}{H}{\cdot}}
    \qquad
    \prftree[r]{\rle{rw-tm}}
      {\isrw{\mc{H}}{I}{H}}
      {\mhasty{I}{\Gamma}{p}{\mc{H}(\lhole{X})}{A}{q}}
      {\isrw{\mc{H}}{I}{H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}}}
    \\
    \prftree[r]{\rle{rw-blk}}
      {\isrw{\mc{H}}{I}{H}}
      {\mhaslb{I}{\Gamma}{\mc{H}(\lhole{T})}{\ms{L}}}
      {\isrw{\mc{H}}{I}{H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}}}
    \qquad
    \prftree[r]{\rle{rw-cfg}}
      {\isrw{\mc{H}}{I}{H}}
      {\mlhaslb{I}{\ms{L}}{\mc{H}(\lhole{W})}{\ms{K}}}
      {\isrw{\mc{H}}{I}{H, \cfghole{\lhole{L}}{\ms{L}}{\ms{K}}}}
  \end{gather*}
  \caption{Typing rules for \isotopessa rewrites}
  \Description{Typing rules for isotope-SSA rewrites}
  \label{fig:rewrite-typing}
\end{figure}

\TODO{some text about rewrite typing rules}

\begin{theorem}[Rewriting]
  Given \(\isrw{\mc{H}}{H}{I}\), we have
  \begin{itemize}
    \item If \(\mhasty{H}{\Gamma}{p}{a}{A}{q}\), then \(\mhasty{I}{\Gamma}{p}{[\mc{H}]a}{A}{q}\)
    \item If \(\mhaslb{H}{\Gamma}{t}{\ms{L}}\), then \(\mhaslb{I}{\Gamma}{[\mc{H}]t}{\ms{L}}\)
  \end{itemize}
  
  Furthermore, we have that 
  \begin{itemize}
    \item \(\mhasty{\cdot}{\Gamma}{p}{a}{A}{q} \iff \hasty{\Gamma}{p}{a}{A}{q}\)
    \item \(\mhaslb{\cdot}{\Gamma}{t}{\ms{L}} \iff \haslb{\Gamma}{t}{\ms{L}}\)
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about rewriting}

\section{SSA Semantics}

\begin{definition}[Substructural Monoidal Category]
  A \textbf{substructural monoidal category} is a tuple \((\mc{C}, \mc{A}, \mc{R})\) where:
  \begin{itemize}
    \item \(\mc{C}\) is a family of categories \(\mc{C}^q\) parametrized by subsets \(q \subseteq \{\ms{a}, \ms{r}\}\) such that
    \begin{itemize}
      \item For all \(q \subseteq q'\), \(\mc{C}^{q'}\) is a wide subcategory of \(\mc{C}^q\), and in particular all object sets \(|\mc{C}^q|\) are the same. We will write this set as \(|\mc{C}|\)
      \item All \(\mc{C}^q\) share symmetric monoidal structure, and are individually closed under the tensor products of morphisms
      \item \(\mc{C}^{q \cap q'} = \mc{C}^q \cap \mc{C}^{q'}\)
    \end{itemize}
    \item \(\mc{A} \subseteq |\mc{C}|\) is a set of \textbf{affine} objects closed under tensor products, such that
    \begin{itemize}
      \item \(\mb{1} \in \mc{A}\)
      \item Every \(A\) in \(\mc{A}\) is equipped with a morphism \(\ms{drop}(A): \mc{C}^{\{\ms{a}, \ms{r}\}}(A, \mb{1})\)
      \item \(\forall A, B \in \mc{A}, \ms{drop}(A \otimes B) = \ms{drop}(A) \otimes \ms{drop}(B);\lambda_I\)
      \item \(\forall A, B \in \mc{A}, \forall f: \mc{C}^{\{\ms{a}\}}(A, B), f;\ms{drop}(B) = \ms{drop}(A)\)
    \end{itemize}
    \item \(\mc{R} \subseteq |\mc{C}|\) is a set of \textbf{relevant} objects closed under tensor products, such that
    \begin{itemize}
      \item \(\mb{1} \in \mc{R}\)
      \item Every \(A\) in \(\mc{R}\) is equipped with a morphism \(\ms{split}(A): \mc{C}^{\{\ms{a}, \ms{r}\}}(A, A \otimes A)\)
      \item \(\forall A, B \in \mc{R}, \ms{split}(A \otimes B) = \ms{split}(A) \otimes \ms{split}(B);\alpha;A \otimes \sigma_{A, B} \otimes B;\alpha\)
      \item Associativity: \(\forall A \in \mc{R}, \ms{split}(A);\ms{split}(A) \otimes A;\alpha = \ms{split}(A);A \otimes \ms{split}(A)\)
      \item Commutativity: \(\forall A \in \mc{R}, \ms{split}(A);\sigma = \ms{split}(A)\)
      \item Comonoid: \(\forall A \in \mc{A} \cap \mc{R}, \ms{split}(A);A \otimes \ms{drop}(A) = \rho_A^{-1} \quad \ms{split}(A);\ms{drop}(A) \otimes A = \lambda_A^{-1}\)
    \end{itemize}
  \end{itemize}
  We call the morphisms in \(\mc{C}^{\{\ms{a}\}}\) \textbf{affine}, the morphisms in \(\mc{C}^{\{\ms{r}\}}\) \textbf{relevant}, and the morphisms in \(\mc{C}^{\{\ms{a}, \ms{r}\}}\) \textbf{pure} or \textbf{intuitionistic}. We call the morphisms in \(\mc{C}^\varnothing\) but not necessarily in any of the other \(\mc{C}^q\) \textbf{linear}. We call a substructural monoidal category a \textbf{substructural Cartesian category} if \(\mc{A} = \mc{R} = |\mc{C}|\), in which case \(\mc{C}^{\{\ms{a}, \ms{r}\}}\) is Cartesian.
\end{definition}
A simple example of a substructural Cartesian category is the category of relations \(\ms{Rel}\), viewed as the Kleisli category of the power-set monad with morphisms of the form \(\ms{Rel}(A, B) = A \to \mc{P}(B)\). In particular, we can define:
\begin{equation}
  \begin{aligned}
    \ms{Rel}^\varnothing(A, B) 
    &= \ms{Rel}(A, B) 
    &&= A \to \mc{P}(B) \\
    \ms{Rel}^{\{\ms{a}\}}(A, B) 
    &= \{R \in \ms{Rel}(A, B) \mid \forall a, |R(a)| \geq 1\} 
    &&= A \to \mc{P}^+(B) \\
    \ms{Rel}^{\{\ms{r}\}}(A, B) 
    &= \{R \in \ms{Rel}(A, B) \mid \forall a, |R(a)| \leq 1\} 
    &&= A \to \ms{Option}(B) \\
    \implies \ms{Rel}^{\{\ms{a}, \ms{r}\}}(A, B) 
    &= \{R \in \ms{Rel}(A, B) \mid \forall a, |R(a)| = 1\} 
    &&= A \to B
  \end{aligned}
\end{equation}
Here, \(\ms{split}(A)\) is just the copy operator \(a \mapsto (a, a)\) and \(\ms{drop}(A)\) the deletion operator \(a \mapsto ()\); it is quite trivial to prove that these lie in \(\ms{Rel}^{\{\ms{a}, \ms{r}\}}\), being functions, and that they satisfy the axioms of a commutative comonoid, as desired. 

Note that we cannot simply have \(\ms{Rel}^{\{\ms{a}\}} = \ms{Rel}\), since, for any morphism \(R: \ms{Rel}(A, B)\) such that \(\exists a \in A, R(a) = \varnothing\), we have
\begin{equation}
  (R;\ms{drop}(B))(a) = \varnothing \neq \ms{drop}(A)(a) = \{()\}
\end{equation}
We will see that this corresponds to the fact that the following programs are not semantically equal
\begin{equation}
  \ms{let}\;x = \ms{loop}(); e \not\simeq e \qquad \text{where} \qquad x \notin \ms{fv}(e)
\end{equation}
Similarly, we cannot simply have \(\ms{Rel}^{\{\ms{r}\}} = \ms{Rel}\), since, for any morphism \(R: \ms{Rel}(A, B)\) such that \(\exists a \in A, |R(a)| \supseteq \{b_0, b_1\}\) where \(b_0 \neq b_1\), we have that
\begin{equation}
  (R;\ms{split}(B))(a) = \{(b, b) \mid b \in R(a)\} \neq (\ms{split}(A);R)(a) = R(a) \times R(a) 
\end{equation}
since only the left-hand side contains the pair \((b_0, b_1)\), this corresponding to the fact that the following programs are not semantically equal
\begin{equation}
  \ms{let}\;x = \ms{rand}(); (x, x) \not\simeq (\ms{rand}(), \ms{rand}())
\end{equation}
Rather than directly give a concrete example of a general substructural monoidal category, it makes more sense to first jump to the next definition, which will provide us with one more naturally:
\begin{definition}[Susbtructural Effectful Category]
  A \textbf{substructural effectful category} \(\mc{C}_1 \to \mc{C}_0\) consists of
  \begin{itemize}
    \item A substructural monoidal category \(\mc{C}_1\); we call the morphisms in this category \textbf{central}
    \item A symmetric premonoidal category \(\mc{C}_0\)
    \item An identity-on-objects functor \(\upg{\cdot}{}: \mc{C}_1^\varnothing \to \mc{C}_0\) preserving all symmetric premonoidal structure (which naturally induces functors \(\upg{\cdot}{}: \mc{C}_1^q \to \mc{C}_0\) which do the same)
  \end{itemize}
  We'll define \(\mc{C}_0^q\) to simply be \(\mc{C}_0\) to allow us to write \(\mc{C}_p^q\) for all \(p \in \{0, 1\}\), \(q \subseteq \{\ms{a}, \ms{r}\}\). Following this convention, we define \(\upg{f}{0}\) to be \(\upg{f}{}\) for morphisms in \(\mc{C}_1^q\) and simply \(f\) for morphisms in \(\mc{C}_0\), and \(\upg{f}{1}\) to simply be the identity functor on \(\mc{C}_1^q\).
\end{definition}

We can obtain an example of a substructural effectful category quite easily by, considering the power-set monad above, applying the state transformer to yield the Kliesli category with morphisms of the form \(\mc{C}_0(A, B) = A \to S \to \mc{P}(A \times S)\). Letting \(\mc{C}_1^q = \ms{Rel}^q\) and defining
\(
  \upg{R}{} = \lambda a, s. R(a) \times \{s\}
\), we can verify that this satisfies the axioms of a substructural effectful category.
Note that here the \textit{central} morphisms are precisely those which do not read from or write to the state, and therefore which commute with all other morphisms.

We can further use this example to get a substructural \textit{monoidal} category by considering a primitive form of separation logic: let's introduce a grammar of predicates \(\varphi, \psi ::= \top, \ms{S}, \bot\) for programs which cannot access state, can access state, and are invalid, respectively. The separating conjunction operator on these predicates is then given by
\begin{equation}
  \top * \varphi = \varphi * \top = \varphi
  \qquad
  \bot * \varphi = \varphi * \bot = \bot
  \qquad
  \ms{S} * \ms{S} = \bot
\end{equation}
We'll then define a category \(\ms{SRel}\) with objects of the form \((A, \varphi)\) and morphisms
\begin{equation}
  \begin{gathered}
    \boxed{
      \ms{SRel}((A, \varphi), (B, \psi)) 
      \subseteq A \to \ms{S} \to \mc{P}(A \times S) 
    }
    \\
    \begin{aligned}
      \ms{SRel}((A, \top), (B, \top)) &= \{f \in A \to S \to \mc{P}(A \times S) \mid \exists g. f = \lambda a, s. g(a) \times \{s\}\} \\
      \ms{SRel}((A, \ms{S}), (B, \ms{S})) &= A \to S \to \mc{P}(A \times S) \\
      \ms{SRel}((A, \varphi), (B, \psi)) &= \{\lambda a, s. \varnothing\} \quad \text{otherwise}
    \end{aligned}
  \end{gathered}
\end{equation}
Note that it is precisely the \textit{central} morphisms \(\ms{C}_0(A, B)\) which lie in \(\ms{SRel}((A, \top), (B, \top))\). We can then define the tensor product on objects as \((A, \varphi) \otimes (B, \psi) = (A \otimes B, \varphi * \psi)\), and, for \(f \in \mathsf{SRel}((A, \varphi), (B, \psi))\), and tensor product functors
\begin{equation}
  \begin{aligned}
  f \otimes (C, \phi) &= f \otimes C,
  & (C, \phi) \otimes f &= C \otimes f
  && \text{if}\; \varphi * \phi \neq \bot, \psi * \phi \neq \bot \\
  f \otimes (C, \phi) &= \lambda a, s. \varnothing,
  & (C, \phi) \otimes f &=  \lambda a, s. \varnothing
  && \text{otherwise}
  \end{aligned} 
\end{equation}
Lifting associators, unitors, and symmetries from \(\mc{C}_0\) in the obvious manner (setting them to \(\lambda a, s. \varnothing\) where necessary), we can verify that \(\ms{SRel}\) is a \textit{premonoidal} category. we can see that it is in fact \textit{monoidal} by nothing that, for any \(f, g\), \(f \ltimes g = f \rtimes g\) since either \(f\) is central, \(g\) is central, or their product is the empty morphism \(\lambda a, s. \varnothing\). Hence, to get a \textit{substructural} monoidal category, we simply need to define:
\begin{equation}
  \begin{gathered}
  \ms{Aff}(\ms{SRel}) = \ms{Rel}(\ms{SRel}) = \{(A, \top) | A \in \ms{Set}\} \neq |\ms{SRel}|
  \\
  \begin{aligned}
    \ms{SRel}^\varnothing((A, \phi), (B, \psi))
    &= \ms{SRel}((A, \phi), (B, \psi)) \\
    \ms{SRel}^{\{\ms{a}\}}((A, \phi), (B, \psi)) 
    &= \{f \in \ms{SRel}((A, \phi), (B, \psi)) \mid \forall a, s. |f(a, s)| \geq 1 \lor \phi \neq \psi \lor \phi = \bot \} \\
    \ms{SRel}^{\{\ms{r}\}}((A, \phi), (B, \psi)) 
    &= \{f \in \ms{SRel}((A, \phi), (B, \psi)) \mid \forall a, s. |f(a, s)| \leq 1 \lor \phi \neq \psi \lor \phi = \bot \} \\
    \implies \ms{SRel}^{\{\ms{a}, \ms{r}\}}((A, \phi), (B, \psi)) 
    &= \{f \in \ms{SRel}((A, \phi), (B, \psi)) \mid \forall a, s. |f(a, s)| = 1 \lor \phi \neq \psi \lor \phi = \bot \} \\
  \end{aligned}
  \end{gathered}
\end{equation}
We can verify that the associators, unitors, and symmetry lie in \(\ms{SRel}^{\{\ms{a}, \ms{r}\}}\) and that all other desired axioms are satisfied.

\TODO{distributive category}

\TODO{Elgot category}

The semantics for an \isotopessa dialect are given by:
\begin{itemize}
  \item A family of categories \(\mc{C}^q_1\) parametrized by quantity \(q \subseteq \{\trel, \taff\}\)
  \item \(q \subseteq q'\) implies \(\mc{C}^{q'}_1\) is a wide subcategory of \(\mc{C}^q_1\)
  \item All \(\mc{C}^q_1\) share symmetric monoidal structure (i.e., the inclusion functors between them are strict symmetric monoidal functors).
  \item A symmetric premonoidal category \(\mc{C}_0\) equipped with an Elgot structure
  \item An object \(\mb{2}\), morphisms \(\ms{tt}, \ms{ff}: \mc{C}_1^\tint(\mb{1}, \mb{2})\), and a family of isomorphisms \(\ms{ite}_A: 2 \otimes A \simeq A + A\) such that 
  \begin{itemize}
    \item \(\ms{ite}_A^{-1} = [\lambda_A^{-1};\ms{tt} \otimes A, \lambda_A^{-1};\ms{ff} \otimes A]\)
    \item \(\mb{2} \otimes f;\ms{ite}_A = \ms{ite}_A;f + f\)
  \end{itemize}
  \item An identity on objects functor functor \(\upg{\cdot}{}: \mc{C}^\varnothing_1 \to \mc{C}_0\) which preserves all symmetric premonoidal structure
  \item A mapping from base types \(X\) to objects in \(\dnt{X}: |\mc{C}|\)
  \item A mapping from functions \(f \in \mc{I}_p^q(A, B)\) to morphisms \(\dnt{f}: \mc{C}_p^q(\dnt{A}, \dnt{B})\), where \(\mc{C}_0^q = \mc{C}_0\)
  \item A set of \textit{affine} objects \(A, B \in \ms{Aff}(\mc{C}) \subseteq |\mc{C}|\) equipped with maps \(\ms{drop}(A): \mc{C}_1^\tint(A, \mb{1})\) such that:
  \begin{itemize}
    \item \(\ms{drop}(A \otimes B) = \ms{drop}(A) \otimes \ms{drop}(B); \lambda_\mb{1}\)
    \item For all \(f: \mc{C}^\taff_1(A, B), f;\ms{drop}(B) = \ms{drop}(A)\)
  \end{itemize}
  \item A set of \textit{relevant} objects \(A, B \in \ms{Rel}(\mc{C}) \subseteq |\mc{C}|\) equipped with maps \(\ms{split}(A): \mc{C}_1^\tint(A, A \times A)\) such that:
  \begin{itemize}
    \item \(\ms{split}(A \otimes B) = \ms{split}(A) \otimes \ms{split}(B);\alpha;A \otimes \sigma_{A, B} \otimes B;\alpha\)
    \item For all \(f: \mc{C}^\trel_1(A, B), f;\ms{split}(B) = \ms{split}(A);f \otimes f\)
    \item \textit{Commutativity}: \(\ms{split}(A);\sigma = \ms{split}(A)\)
    \item \textit{Associativity}: \(\ms{split}(A);A \otimes \ms{split}(A) = \ms{split}(A);\ms{split}(A) \otimes A;\alpha\)
    \item \textit{Comonoid}: if \(A \in \ms{Aff}(\mc{C})\), \(\ms{split}(A);\ms{drop}(A) \otimes A = \lambda^{-1}\) and \(\ms{split}(A);A \otimes \ms{drop}(A) = \rho^{-1}\)
  \end{itemize}
\end{itemize}

\TODO{premonoidal/effectful categories}

\TODO{Elgot structure}

\TODO{relevant/affine/intuitionistic subcategories}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{A}}: |\mc{C}| \\
    \dnt{X} = \ms{base}(X) 
      \text{ where } 
      \dnt{\mb{1}} = \mb{1}, 
      \dnt{\mb{2}} = \mb{2}
    \qquad \dnt{A \otimes B} = \dnt{A} \otimes \dnt{B} \\
    \boxed{\dnt{\Gamma}}: |\mc{C}| \\
    \dnt{\cdot} = \mb{1} \qquad 
    \dnt{\Gamma, \thyp{x}{A}{q}} = \dnt{\Gamma} \otimes \dnt{A} \\
    \boxed{\dnt{\ms{L}}}: |\mc{C}| \\
    \dnt{\cdot} = \mb{0} \qquad
    \dnt{\ms{L}, \llhyp{\ell}{\Gamma}{A}} = 
      \dnt{\ms{L}} + \dnt{\Gamma} \otimes \dnt{A}
  \end{gather*}
  \caption{Semantics for \isotopessa types and contexts}
  \Description{Semantics for isotope-SSA types and contexts}
  \label{fig:ssa-type-semantics}
\end{figure}

\TODO{some text about type/context semantics}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\tlin{A}{\taff}: \mc{C}_1^\tint(\dnt{A}, \mb{1})}}
      \\
    \dnt{\tlin{X}{\taff}} = \ms{drop}(X) \qquad
    \dnt{\tlin{A \otimes B}{\taff}} 
      = \dnt{\tlin{A}{\taff}} \otimes \dnt{\tlin{B}{\taff}}
      ; \lambda \\
    \boxed{\dnt{\tlin{A}{\trel}}
      : \mc{C}_1^\tint(\dnt{A}, \dnt{A} \otimes \dnt{A})}
      \\
    \dnt{\tlin{X}{\trel}} = \ms{split}(X) \qquad
    \dnt{\tlin{A \otimes B}{\trel}} = 
      \dnt{\tlin{A}{\trel}} \otimes \dnt{\tlin{B}{\trel}}
      ;\alpha;\dnt{A} \otimes \sigma \otimes \dnt{B};\alpha 
      \\
    \boxed{\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
      : \mc{C}_1^\tint(\dnt{\Gamma}, \dnt{\Delta} \otimes \dnt{\Xi})}
      \\
    \dnt{\csplits{\cdot}{\cdot}{\cdot}} = \lambda^{-1} \qquad
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta, \thyp{x}{A}{q}}
      {\Xi}} 
      = \dnt{\csplits{\Gamma}{\Delta}{\Xi}} \otimes \dnt{A};\alpha;\dnt{\Delta} \otimes \sigma;\alpha 
      \\
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta}
      {\Xi, \thyp{x}{A}{q}}} 
      = \dnt{\csplits{\Gamma}{\Delta}{\Xi}} \otimes \dnt{A};\alpha 
      \\
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta}
      {\Xi, \thyp{x}{A}{q}}} \
      = \dnt{\Gamma} \otimes \dnt{\tlin{A}{\trel}};
        \alpha;
        \dnt{\Delta} \otimes \sigma \otimes \dnt{A};
        \alpha 
        \\
    \dnt{\csplits
      {\Gamma, \thyp{x}{A}{q}}
      {\Delta}
      {\Xi}}
      = \dnt{\csplits{\Gamma}{\Delta}{\Xi}}
        \otimes \dnt{\tlin{A}{\taff}}
      ; \rho 
      \\
    \boxed{\dnt{\cwk{\Gamma}{\Delta}}
      : \mc{C}_1^\tint(\dnt{\Gamma}, \dnt{\Delta})} 
      \\
      \dnt{\cwk{\Gamma}{\Delta}} 
      = \dnt{\csplits{\Gamma}{\Delta}{\cdot}};\rho 
      \\
    \boxed{\dnt{\lwk{\ms{L}}{\ms{K}}}
      : \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}})} 
      \\
    \dnt{\lwk{\cdot}{\cdot}} = \ms{id} \qquad
    \dnt{\lwk
      {\ms{L}, \llhyp{\ell}{\Gamma}{A}}
      {\ms{K}, \llhyp{\ell}{\Delta}{A}}}
      = \dnt{\lwk{\ms{L}}{\ms{K}}} + \upg{(\cwk{\Gamma}{\Delta} \otimes \dnt{A})}{} 
      \\
    \dnt{\lwk{\ms{L}}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      = \dnt{\lwk{\ms{L}}{\ms{K}}};\rho_+^{-1}
      ; \dnt{\ms{K}} \oplus 0_{\dnt{\Gamma} \otimes \dnt{A}}
  \end{gather*}
  \caption{Semantics for \isotopessa structural judgements}
  \Description{Semantics for isotope-SSA structural judgements}
  \label{fig:ssa-structural-semantics}
\end{figure}

\TODO{some text about structural semantics}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\hasty{\Gamma}{p}{a}{A}{q}}
      : \mc{C}_p^q(\dnt{\Gamma}, \dnt{A})} 
      \\
    \dnt{\hasty{\Gamma}{p}{x}{A}{q}} 
      = \dnt{\cwk{\Gamma}{\thyp{x}{A}{q}}}
      \qquad
    \dnt{\hasty{\Gamma}{p}{f\;a}{B}{q}}
      = \upg{\dnt{\hasty{\Gamma}{1}{a}{A}{q}}}{p}
      ; \ms{inst}_p(f) 
      \\
    \dnt{\hasty{\Gamma}{p}{(a, b)}{A \otimes B}{q}}
      = \upg{(
        \dnt{\csplits{\Gamma}{\Delta}{\Xi}};
        \dnt{\hasty{\Delta}{1}{a}{A}{q}} \otimes
        \dnt{\hasty{\Xi}{1}{b}{B}{q}}
      )}{\uparrow p} 
      \\
    \dnt{\hasty{\Gamma}{p}{()}{\mb{1}}{q}}
      = \upg{\dnt{\cwk{\Gamma}{\cdot}}}{p} 
      \\
    \dnt{\hasty{\Gamma}{p}{\ctt}{\mb{2}}{q}}
      = \upg{(\dnt{\cwk{\Gamma}{\cdot}};\ctt)}{p}
      \qquad
    \dnt{\hasty{\Gamma}{p}{\cff}{\mb{2}}{q}}
      = \upg{(\dnt{\cwk{\Gamma}{\cdot}};\cff)}{p} 
      \\
    \dnt{\hasty{\Gamma}{p}{\letexpr{x}{a}{e}}{B}{q}}
      = \upg{(
        \dnt{\csplits{\Gamma}{\Delta}{\Xi}}
        ; \dnt{\Delta} \otimes \dnt{\hasty{\Xi}{1}{a}{A}{q}}
      )}{p};\dnt{\hasty{\Delta, \thyp{x}{A}{}}{p}{e}{B}{q}} 
      \\
    \dnt{\hasty{\Gamma}{p}{\letexpr{(x, y)}{a}{e}}{C}{q}}
      = \upg{(
        \dnt{\csplits{\Gamma}{\Delta}{\Xi}}
        ; \dnt{\Delta} \otimes \dnt{\hasty{\Xi}{1}{a}{A \otimes B}{q}}
      )}{p}
      ; 
      \\ \qquad \qquad \qquad \qquad \qquad \alpha
      ; \dnt{\hasty{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{p}{e}{C}{q}}
      \\
    \dnt{\hasty{\Gamma}{0}{\lbsplice{\ell}{A}{t}}{A}{\varnothing}}
      = \dnt{\haslb{\Gamma}{t}{\llhyp{\ell}{\cdot}{A}}};\alpha_+
  \end{gather*}
  \caption{Semantics for \isotopessa terms}
  \Description{Semantics for isotope-SSA terms}
  \label{fig:ssa-structural-terms}
\end{figure}

\TODO{some text about term semantics}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\haslb{\Gamma}{t}{\ms{L}}}
      : \mc{C}_0(\dnt{\Gamma}, \dnt{\ms{L}})} \\
    \dnt{\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}}
      = \upg{(\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
      ; \dnt{\Delta} \otimes \dnt{\hasty{\Xi}{1}{a}{A}{\tint}})}
      ; \dnt{\lwk{\llhyp{\ell}{\Delta}{A}}{\ms{L}}} \\
    \dnt{\haslb{\Gamma}{\ite{e}{s}{t}}{\ms{L}}}
      = \upg{(\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
      ; \dnt{\hasty{\Delta}{1}{e}{\mb{2}}{\tint}} \otimes \dnt{\Xi})}
      ; \ms{ite}_{\dnt{\Xi}} ;
      \\ \qquad \qquad \qquad \qquad
      [
        \dnt{\haslb{\Xi}{s}{\ms{L}}}, 
        \dnt{\haslb{\Xi}{t}{\ms{L}}} 
      ]
      \\
    \dnt{\haslb{\Gamma}{\letstmt{x}{a}{t}}{\ms{L}}}
      = \upg{\dnt{\csplits{\Gamma}{\Delta}{\Xi}}}
      ; \dnt{\Delta} \otimes \dnt{\hasty{\Gamma}{0}{a}{A}{q}}
      ; \dnt{\haslb{\Delta, \thyp{x}{A}{}}{t}{\ms{L}}}
      \\
    \dnt{\haslb{\Gamma}{\letstmt{(x, y)}{a}{t}}{\ms{L}}}
      = \upg{\dnt{\csplits{\Gamma}{\Delta}{\Xi}}}
      ; \dnt{\Delta} \otimes \dnt{\hasty{\Gamma}{0}{a}{A \otimes B}{q}}
      ; \alpha
      ; \dnt{\haslb{\Delta, \thyp{x}{A}{}, \thyp{y}{B}{}}{t}{\ms{L}}}
      \\
    \dnt{\haslb{\Gamma}{\ewhere{t}{L}}{\ms{K}}}
      = \dnt{\haslb{\Gamma}{t}{\ms{L}}}
      ; \dnt{\lhaslb{\ms{L}}{L}{\ms{K}}}^\dagger
      \\
    \boxed{\dnt{\lhaslb{\ms{L}}{L}{\ms{K}}}
      : \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}} + \dnt{\ms{L}})}
      \\
    \dnt{\lhaslb{\ms{L}}{L, \lwbranch{\ell}{x: A}{t}}{\ms{K}}}
      = \dnt{\lhaslb{\ms{L}}{L}{\ms{K}, \llhyp{\ell}{\Gamma}{A}}}
      ; [[\iota_0, \dnt{\haslb{\Gamma, \thyp{x}{A}{}}{t}{\ms{L}}}], \iota_1]
      \\
    \dnt{\lhaslb{\ms{L}}{\cdot}{\ms{L}}}
      = \iota_0
  \end{gather*}
  \caption{Semantics for \isotopessa blocks}
  \Description{Semantics for isotope-SSA blocks}
  \label{fig:ssa-structural-blocks}
\end{figure}

\TODO{some text about block semantics}

\subsection{Semantic Metatheory}

\TODO{some text about semantic metatheory}

\begin{lemma}[Coherence] \
  \begin{itemize}
    \item Given any two derivations \(D_1: \hasty{\Gamma}{p}{a}{A}{q}\), \(D_2: \hasty{\Gamma}{p}{a}{A}{r}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \haslb{\Gamma}{t}{\ms{L}}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \csplits{\Gamma}{\Delta}{\Xi}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \cwk{\Gamma}{\Delta}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \lwk{\ms{L}}{\ms{K}}\), \(\dnt{D_1} = \dnt{D_2}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix? This is just a trivial induction.}

\TODO{some text about coherence, implicit use above}

\begin{lemma}[Semantic Upgrade]
  For all \(\Gamma, a, A\), if \(\hasty{\Gamma}{1}{a}{A}{q}\), then
  \[\dnt{\hasty{\Gamma}{0}{a}{A}{q}} = \upg{\hasty{\Gamma}{1}{a}{A}{q}}{}\]
\end{lemma}

\TODO{some text about upgrade}

\begin{lemma}[Semantic Weakening] 
  If \(\cwk{\Gamma}{\Delta}\), then 
  \begin{itemize}
    \item For all \(\hasty{\Delta}{p}{a}{A}{q}\),
    \[
      \upg{\dnt{\cwk{\Gamma}{\Delta}}}{p}
      ; \dnt{\hasty{\Delta}{p}{a}{A}{q}}
      = \dnt{\hasty{\Gamma}{p}{a}{A}{q}} 
    \]
    \item For all \(\haslb{\Delta}{t}{\ms{L}}\),
    \[
      \upg{\dnt{\cwk{\Gamma}{\Delta}}}{p}
      ; \dnt{\haslb{\Delta}{t}{\ms{L}}}
      = \dnt{\haslb{\Gamma}{t}{\ms{L}}}  
    \]
  \end{itemize}

  Similarly, if \(\lwk{\ms{L}}{\ms{K}}\) and \(\haslb{\Gamma}{t}{\ms{L}}\), then
  \[
    \dnt{\haslb{\Gamma}{t}{\ms{L}}}
    ; \dnt{\lwk{\ms{L}}{\ms{K}}}
    = \dnt{\haslb{\Gamma}{t}{\ms{K}}}
  \]
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{some text about semantic weakening}

\begin{figure}
  \begin{gather*}
    \boxed{\dnt{\issubst{\gamma}{\Theta}{\Gamma}}: \mc{C}_1^\varnothing(\dnt{\Theta}, \dnt{\Gamma})} 
    \\
    \dnt{\issubst{\gamma}{\Theta}{\Gamma, \thyp{x}{A}{q}}}
      = \dnt{\csplits{\Theta}{\Theta_\Gamma}{\Theta_x}};\dnt{\issubst{\gamma}{\Theta_\Gamma}{\Gamma}} \otimes \dnt{\hasty{\Theta_x}{1}{a}{A}{q}} \\
    \dnt{\issubst{\cdot}{\cdot}{\cdot}} = \ms{id}
    \\
    \boxed{\dnt{\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}: \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}})} 
  \end{gather*}
  \caption{Semantics for \isotopessa substitutions}
  \Description{Semantics for isotope-SSA substitutions}
  \label{fig:ssa-subst-semantics}
\end{figure}

\TODO{some text about substitution semantics}

\begin{lemma}[Substitution Coherence] \
  \begin{itemize}
    \item Given any two derivations \(D_1: \issubst{\gamma}{\Theta}{\Gamma}\), \(D_2: \issubst{\gamma'}{\Theta}{\Gamma}\) such that \(\forall x \in \Theta, \gamma(x) = \gamma'(x)\), we have \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1: \lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\), \(D_2: \lbsubst{\mc{L}'}{\ms{L}}{\ms{K}}\) such that \(\forall \lbl{\ell} \in \ms{L}, \mc{L}(x) = \mc{L}'(x)\), we have \(\dnt{D_1} = \dnt{D_2}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix? just trivial induction.}

\begin{lemma}[Semantic Substitution Splitting] 
  Given \(\csplits{\Gamma}{\Delta}{\Xi}\) and \(\issubst{\gamma}{\Delta}{\Xi}\),
  if \(\csplits{\Theta}{\Theta_\Delta}{\Theta_\Xi}\) and \(\issubst{\gamma}{\Theta_\Delta}{\Delta}\), \(\issubst{\gamma}{\Theta_\Xi}{\Xi}\), then
  \[
    \dnt{\issubst{\gamma}{\Theta}{\Gamma}};\dnt{\csplits{\Gamma}{\Delta}{\Xi}}
    = \dnt{\csplits{\Theta}{\Theta_\Delta}{\Theta_\Xi}};
      \dnt{\issubst{\gamma}{\Theta_\Delta}{\Delta}}
      \otimes \dnt{\issubst{\gamma}{\Theta_\Xi}{\Xi}}
  \]
\end{lemma}

\begin{theorem}[Semantic Substitution] 
  Given \(\issubst{\gamma}{\Theta}{\Gamma}\),
  \begin{itemize}
    \item For all \(\hasty{\Gamma}{p}{a}{A}{q}\), 
    \[
      \upg{\dnt{\issubst{\gamma}{\Theta}{\Gamma}}}{p}
      ;\dnt{\hasty{\Gamma}{p}{a}{A}{q}} 
      = \dnt{\hasty{\Theta}{p}{[\gamma]a}{A}{q}}
    \]
    \item For all 
      \(\haslb{\Gamma}{t}{\ms{L}}\), 
      \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\), 
      \(\haslb{\Theta}{[\gamma]t}{\ms{K}}\),
    \[
      \upg{\dnt{\issubst{\gamma}{\Theta}{\Gamma}}}{}
      ; \dnt{\haslb{\Gamma}{t}{\ms{L}}}
      = \dnt{\haslb{\Theta}{[\gamma]t}{\ms{K}}} 
      ; \dnt{\lbsubst{\substlbs{\gamma}{\ms{K}}}{\ms{K}}{\ms{L}}}
    \]
    \item For all 
      \(\lhaslb{\ms{W}}{L}{\ms{L}}\), 
      \(\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}\),
      \(\lbsubst{\substlbs{\gamma}{\ms{W'}}}{\ms{W}}{\ms{W'}}\),
      \[
        \dnt{\lbsubst{\substlbs{\gamma}{\ms{W'}}}{\ms{W}}{\ms{W'}}}
        ; \dnt{\lhaslb{\ms{W'}}{[\gamma]L}{\ms{K}}}
        = \dnt{\lhaslb{\ms{W}}{L}{\ms{L}}}
        ; \dnt{\lbsubst{\substlbs{\gamma}{\ms{L}}}{\ms{K}}{\ms{L}}}
        + \dnt{\lbsubst{\substlbs{\gamma}{\ms{W'}}}{\ms{W}}{\ms{W'}}}
      \]
  \end{itemize}
  Similarly, given \(\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}\),
  \begin{itemize} 
    \item For all \(\haslb{\Gamma}{t}{\ms{L}}\), we have
    \[
      \dnt{\haslb{\Gamma}{t}{\ms{L}}};\dnt{\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}
      = \dnt{\haslb{\Gamma}{[\mc{L}]t}{\ms{K}}}
    \]
    \item For all \(\lhaslb{\ms{W}}{L}{\ms{L}}\), we have
    \[
      \dnt{\lhaslb{\ms{W}}{L}{\ms{L}}};\dnt{\lbsubst{\mc{L}}{\ms{L}}{\ms{K}}}
      = \dnt{\lhaslb{\ms{W}}{[\mc{L}]L}{\ms{L}}}
    \]
  \end{itemize}
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}
\TODO{float proof to appendix}

\TODO{some text about semantic substitution}

\begin{figure}
  \begin{align*}
    \dnt{H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}}
      &= \dnt{H} \times \mc{C}_p^q(\dnt{\Gamma}, \dnt{A}) 
      \\
    \dnt{H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}}
      &= \dnt{H} \times \mc{C}_0(\dnt{\Gamma}, \dnt{\ms{L}}) 
      \\
    \dnt{H, \cfghole{\lhole{W}}{\ms{L}}{\ms{K}}}
      &= \dnt{H} \times \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}} + \dnt{\ms{L}}) 
      \\
    \dnt{\cdot} 
      &= \mb{1}
  \end{align*}
  \caption{Semantics for \isotopessa holes}
  \Description{Semantics for isotope-SSA holes}
  \label{fig:holes-semantics}
\end{figure}

\TODO{some text about semantics of holes}

\begin{figure}
  \begin{gather*}
    \boxed{
      \dnt{\mhasty{H}{\Gamma}{p}{\mhole{a}}{A}{q}}
      : \dnt{H} \to \mc{C}_p^q(\dnt{\Gamma}, \dnt{A})}
      \\
    \sorry
  \end{gather*}
  \caption{Semantics for \isotopessa terms with holes}
  \Description{Semantics for isotope-SSA blocks with holes}
  \label{fig:terms-with-holes-semantics}
\end{figure}

\TODO{fill}

\TODO{some text about semantics of terms with holes}

\begin{figure}
  \begin{gather*}
    \boxed{
      \dnt{\mhaslb{H}{\Gamma}{\mhole{t}}{\ms{L}}}
      : \dnt{H} \to \mc{C}_0(\dnt{\Gamma}, \dnt{\ms{L}})}
      \\
    \sorry
      \\  
    \boxed{
      \dnt{\mlhaslb{H}{\ms{L}}{\mhole{L}}{\ms{K}}}
      : \dnt{H} \to \mc{C}_0(\dnt{\ms{L}}, \dnt{\ms{K}} + \dnt{\ms{L}})}
      \\
    \sorry
  \end{gather*}
  \caption{Semantics for \isotopessa blocks with holes}
  \Description{Semantics for isotope-SSA blocks with holes}
  \label{fig:blocks-with-holes-semantics}
\end{figure}

\TODO{fill}

\TODO{some text about semantics of blocks with holes}

\begin{figure}
  \begin{gather*}
    \boxed{
      \dnt{\isrw{\mc{H}}{I}{H}}
      : \dnt{I} \to \dnt{H} 
    }
    \\
    \dnt{\isrw{\mc{H}}{I}{\cdot}}\;i = ()
    \qquad
    \dnt{\isrw{\mc{H}}{I}{H, \tyhole{\lhole{X}}{\Gamma}{p}{A}{q}}}\;i
    = (\dnt{\isrw{\mc{H}}{I}{H}}\;i, \dnt{\mhasty{I}{\Gamma}{p}{\mc{H}(\lhole{X})}{A}{q}}\;i)
    \\
    \dnt{\isrw{\mc{H}}{I}{H, \blkhole{\lhole{T}}{\Gamma}{\ms{L}}}}
    = (\dnt{\isrw{\mc{H}}{I}{H}}\;i, \dnt{\mhaslb{I}{\Gamma}{\mc{H}(\lhole{T})}{\ms{L}}}\;i)
    \\
    \dnt{\isrw{\mc{H}}{I}{H, \cfghole{\lhole{L}}{\ms{L}}{\ms{K}}}}
    = (\dnt{\isrw{\mc{H}}{I}{H}}\;i, \dnt{\mlhaslb{I}{\ms{L}}{\mc{H}(\lhole{W})}{\ms{K}}}\;i)
  \end{gather*}
  \caption{Semantics for \isotopessa rewrites}
  \Description{Semantics for isotope-SSA rewrites}
  \label{fig:rewrite-semantics}
\end{figure}

\TODO{fill}

\TODO{some text about semantics of rewrites}

\begin{lemma}[Rewriting Coherence] \
  \begin{itemize}
    \item Given any two derivations \(D_1: \mhasty{H}{\Gamma}{p}{a}{A}{q}\), \(D_2: \mhasty{\Gamma}{p}{H}{a}{A}{r}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \mhaslb{H}{\Gamma}{t}{\ms{L}}\), \(\dnt{D_1} = \dnt{D_2}\)
    \item Given any two derivations \(D_1, D_2: \isrw{\mc{H}}{I}{H}\), \(\dnt{D_1} = \dnt{D_2}\)
  \end{itemize}
\end{lemma}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix? just trivial induction}

\begin{theorem}[Semantic Rewriting]
  Given \(\isrw{\mc{H}}{I}{H}\), we have that
  \begin{itemize}
    \item For all \(\mhasty{H}{\Gamma}{p}{a}{A}{q}\), \(m \in \dnt{I}\), we have
    \[
      \dnt{\mhasty{I}{\Gamma}{p}{[\mc{H}]a}{A}{q}}(m)
      = \dnt{\mhasty{H}{\Gamma}{p}{a}{A}{q}}(\dnt{\isrw{\mc{H}}{I}{H}}(m))
    \]
    \item For all \(\mhaslb{H}{\Gamma}{t}{\ms{L}}\), \(m \in \dnt{I}\), we have
    \[
      \dnt{\mhaslb{I}{\Gamma}{[\mc{H}]t}{\ms{L}}}(m)
      = \dnt{\mhaslb{H}{\Gamma}{t}{\ms{L}}}(\dnt{\isrw{\mc{H}}{I}{H}}(m))
    \]
  \end{itemize}

  Furthermore, we have that
  \[
    \dnt{\mhasty{\cdot}{\Gamma}{p}{a}{A}{q}}() = \dnt{\hasty{\Gamma}{p}{a}{A}{q}}
    \qquad
    \dnt{\mhaslb{\cdot}{\Gamma}{t}{\ms{L}}}() = \dnt{\haslb{\Gamma}{t}{\ms{L}}}
  \]
\end{theorem}

\begin{proof} \
  \TODO{this}
\end{proof}

\TODO{pull down to appendix}

\TODO{\(\implies\) E-graph optimization}

\TODO{rewriting substitution + weakening?}

\section{Basic Models}

\TODO{Ye Olde Trace Monad}

\TODO{Is Elgot}

\TODO{Ye Olde Nondeterministic Trace Monad}

\TODO{Is Elgot}

\TODO{Ye Olde Reader/Writer/State Transformer}

\TODO{Is Elgot}

\section{Separation Logic}

\TODO{State transformer on traces}

\TODO{Monoidal functor, yielding sliding}

\section{Weak Memory}

\TODO{Pomsets...}

\TODO{Form a monoid, so we can define...}

\TODO{The SC Monad, which, via composition w/ the state transformer, lets us}

\TODO{Build The Weak Memory Monad, which is too powerful, so we do...}

\TODO{Karoubi envelope as premonoidal demonstration?}

\section{Implementation}

\TODO{this}

\section{Related Work}

\TODO{\cite{promonad}}

\TODO{\cite{linear-state-usage}}

\TODO{\cite{sparky}}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
